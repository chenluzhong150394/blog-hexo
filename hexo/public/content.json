{"meta":{"title":"Mr.chen的blog","subtitle":null,"description":null,"author":"Mr.chen","url":"https://blog.clz.cloud","root":"/"},"pages":[{"title":"","date":"2019-08-10T17:05:06.214Z","updated":"2019-08-10T17:01:46.711Z","comments":true,"path":"404.html","permalink":"https://blog.clz.cloud/404.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T15:26:49.589Z","updated":"2019-08-10T15:26:49.589Z","comments":true,"path":"baidu_verify_XeWR9kzXZ9.html","permalink":"https://blog.clz.cloud/baidu_verify_XeWR9kzXZ9.html","excerpt":"","text":"XeWR9kzXZ9"},{"title":"","date":"2019-08-11T10:55:33.477Z","updated":"2019-08-11T10:55:33.477Z","comments":true,"path":"googlea28ffae42df3c06e.html","permalink":"https://blog.clz.cloud/googlea28ffae42df3c06e.html","excerpt":"","text":"google-site-verification: googlea28ffae42df3c06e.html"},{"title":"about","date":"2019-08-11T18:28:20.000Z","updated":"2019-08-12T03:39:22.429Z","comments":false,"path":"about/index.html","permalink":"https://blog.clz.cloud/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-02T04:33:16.000Z","updated":"2019-08-12T03:46:38.785Z","comments":false,"path":"categories/index.html","permalink":"https://blog.clz.cloud/categories/index.html","excerpt":"","text":""},{"title":"有事请留言","date":"2019-08-12T07:52:05.000Z","updated":"2019-08-12T08:06:27.640Z","comments":true,"path":"message/index.html","permalink":"https://blog.clz.cloud/message/index.html","excerpt":"","text":"有事请留言"},{"title":"tags","date":"2019-08-11T18:28:19.000Z","updated":"2019-08-12T03:37:50.312Z","comments":false,"path":"tags/index.html","permalink":"https://blog.clz.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"centos安装python3时候的坑","slug":"p","date":"2019-08-12T04:22:00.000Z","updated":"2019-08-12T04:27:27.144Z","comments":true,"path":"2019/08/12/p/","link":"","permalink":"https://blog.clz.cloud/2019/08/12/p/","excerpt":"","text":"当使用源码编译安装python3的之后做软链接到/usr/bin,会出现问题,无法执行python命令,就是无法直接做软链接到用户的命令目录下.执行不了 解决方法: 在python的安装目录,对python3.6 这个脚本做软链接,然后再将做好的软链接拷贝到/usr/bin 下就能正常执行python3命令了 pip同理","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"}]},{"title":"Git的安装及常用操作","slug":"git","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:17:50.681Z","comments":true,"path":"2019/08/10/git/","link":"","permalink":"https://blog.clz.cloud/2019/08/10/git/","excerpt":"","text":"安装gitLinux下安装yum安装 1yum -y install git test windows下安装官网地址： https://git-scm.com/download 下载到本地磁盘 安装 一路【next】就可以了 注意：openssl 一定选它 安装完成后，右击菜单栏，有如下菜单，表示安装完成 进入git bash选项 Git工作区、暂存区和版本库 git的使用本地使用git管理代码git项目仓库的本地搭建12345cd进入到自己希望存储代码的目录路径，并创建本地仓库.git新创建的本地仓库.git是个空仓库 cd 目录路径 git init gitdemo # 如果没有声明目录,则自动把当前目录作为git仓库 checkout 切换分支 pull 拉取远程git代码 branch -a 查看所有分支 管理远程git仓库删除远端git项目中的指定文件和目录 首先拉取远程git仓库 123456##如果本地仓库存在，则只需要pull 将远端git仓库与本地git仓库一直git pull##如果本地仓库不存在，则需要克隆clonegit clone https://gitee.com/chenluzhong/blog.git 使用git删除本地文件或目录 123456## 删除本地文件git rm &lt;file_name&gt;## 删除本地目录### -r 参数是递归删除的意思，如果目录是空的，就不用加这个参数也可以 git rm -r &lt;dir_name&gt; 提交代码到本地仓库 1git commit -m '删除某文件后的版本' 将本地仓库推送到远端 1git push &lt;base_url&gt; -u 本地仓库推送到码云首先码云仓库的地址是: https://gitee.com/chenluzhong/lufeiapi.git 设置全局配置(用户名和邮箱) 12git config --global user.name &apos;chenluzhong&apos;git config --global user.email &apos;18438128833@163.com&apos; 创建git仓库 1git init 提交本地的文件到暂存区 1git add . 将暂存区的内容提交到本地仓库中 1git commit -m &apos;这是第一个版本&apos; 然后关联远程仓库地址 1git remote add origin https://gitee.com/chenluzhong/lufeiapi.git 将本地的主分支与远程的分支进行关联 12git branch --set-upstream-to=origin/master mastergit pull orgin master 将本地仓库推送到远端仓库 1234## -u 参数指定唯一主机, master代表将推送到目标仓库的master主分支$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push -u origin master:master branch分支操作查看所有分支 查看本地分支 1git branch 查看远程分支 1git branch -a 创建分支 1git branch dev ##新建一个dev的本地分支 切换分支 1git checkout dev ## 切换到dev这个分支 删除分支 删除本地分支 1git branch -d dev ## 删除本地分支 删除远程分支 1git push origin --delete dev ## 删除远程仓库中dev分支","categories":[{"name":"Git","slug":"Git","permalink":"https://blog.clz.cloud/categories/Git/"}],"tags":[{"name":"git操作","slug":"git操作","permalink":"https://blog.clz.cloud/tags/git操作/"}]},{"title":"数据库常用操作","slug":"l数据库","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-12T01:03:24.833Z","comments":true,"path":"2019/08/10/l数据库/","link":"","permalink":"https://blog.clz.cloud/2019/08/10/l数据库/","excerpt":"","text":"数据库操作数据库的基本操作修改root密码1alter user root identifiled by password &apos;password&apos; MySQL修改用户的密码主要有两种方法：ALTER USER 和SET PASSWORD ALTER USER基本使用 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos;; 修改当前登录用户 1ALTER USER USER() IDENTIFIED BY &apos;123456&apos;; 使密码过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE; 使密码从不过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER; 按默认设置过期时间 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE DEFAULT; 指定过期间隔 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE INTERVAL 90 DAY; 在MySQL文档里，推荐使用ALTER USER修改用户密码 SET PASSWORD使用SET PASSWORD的password有两种： 使用默认加密 1SET PASSWORD FOR testuser = &apos;123456&apos; 使用PASSWORD()函数加密 1SET PASSWORD FOR testuser = PASSWORD(&quot;123456&quot;) 增删查改增加1、增加一个字段 1insert 2、增加一条记录 12 3、在多表关联的情况下，新增一条数据 12 删除1、删除一个字段 12 2、删除一条记录 12 3、删除多表中相关联的数据 12 更新1、更新一个字段名（在不改变原来数据的情况下） 12 2、更新一条数据中的某个字段的数据 12 3、在多表关联的情况下更新相关联的字段数据 12 查询1、单表查询（查询满足特定条件的所有数据） 12 2、使用左连接查询多表 12 修改1、给字段添加注释 12345#### 创建表的时候加注释create table test1(name char(32) comment&apos;字段注释&apos;) comment=‘表注释’；### 修改某个字段的属性并加上注释ALTER table table_name MODIFY `column_name` datetime DEFAULT NULL COMMENT &apos;这是字段的注释&apos; 2、给表加注释 1alter table table_name comment=&apos;这是表的注释&apos;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.clz.cloud/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"}]},{"title":"flask笔记","slug":"flask笔记","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:17:33.919Z","comments":true,"path":"2019/08/10/flask笔记/","link":"","permalink":"https://blog.clz.cloud/2019/08/10/flask笔记/","excerpt":"","text":"FLASK 安装先创建一个虚拟环境，并使用pycharm 初始化一个pure python项目 1mkvirtualenv flask_demo -p python3 1pip install flask==0.12.4 flask的简单组成 初始化flask ==》 路由 创建一个flask 应用 12## 创建flask 应用app = Flask(__name__) 路由-限定请求方式 1234567891011@app.route('/')def idnex(): return '这里是首页'##路由-限定请求方式## route 中有个参数methods 是定义请求类型的，只有定义了才能访问，#默认的是开启get的@app.route('/',methods=[\"get\",\"post\"])def idnex(): return '这里是首页' 开启debug模式 1DEBUG = True 在主文件导入配置文件 123456class Config(object) DEBUG = True app.config.from_object(Config)## 最常用的方式是通过对象的方式， 通过导包，将配置文件加载 启动flask 123456app.run(host='localhost',port=8080,debug=true) # flask 内部作为一个基本的web框架，内置http服务器肯定有的。 #运行flask 可以使用 app.run（） # host 服务器启动时绑定的域名 #port 服务器启动时绑定的端口 #debug 是否开启调试模式 简单的flask demo详解在路由中设置变量（传递参数-两种）123456789101112## 使用'&lt; &gt;' 表示变量名，##&lt;int:变量名&gt;表示限制变量的数据类型@app.route(\"/user/&lt;int:userid&gt;\")def user(userid): return \"用户个人中心%s\" % userid\"\"\"限制参数类型int:变量名 #当前路由内容只能是整型float:变量名 #当前路由内容只能是 浮点数path:变量名 #当前路由内容可以是任何内容\"\"\" 正则匹配路由1.首先导入转换器基类 1from werkzeug.routing import BaseConverter 2.自定义转换器 123456class RegexCover(BaseConverter): def __init__(self, map,*args): super(RegexCover,self).__init__(map) ## 正则参数 self.regex = args[0] 3.将自定义的转换器添加到转换器字典中，并指定转换器使用的别名 1app.url_map.converters['regex'] = RegexCover 4.就可以通过正则去获取参数变量了 1234## regex 后面跟一个元组，元祖里面是正则表达式，mobile是变量名@app.route(\"/user/&lt;regex('\\d+'):mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 预定义正则匹配路由可以直接讲正则(regex)写死,然后直接用就行了一般应用场景是 固定类型的正则（验证手机号的合法等等） 1234567891011## 声明一个固定转换器class Mobileter(BaseConverter): regex = \"1[3-9]\\d&#123;9&#125;\" ## 将上面的转化器注册到转化器字典中app.url_map.converters['mobile'] = Mobileter##使用自定义的转换器，@app.route(\"/user/&lt;mobile:mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 系统自带转换器 werkzeug.routing.py 123456789DEFAULT_CONVERTERS = &#123; \"default\": UnicodeConverter, \"string\": UnicodeConverter, \"any\": AnyConverter, \"path\": PathConverter, \"int\": IntegerConverter, \"float\": FloatConverter, \"uuid\": UUIDConverter,&#125; http的请求与响应在flask中导入 request 模块，用request模块去获取客户端提交的数据 常用的属性如下： 属性 说明 类型 data 记录请求的数据，并转换为字符串 * form 记录请求中的表单数据 MultiDict args 记录请求中的查询参数 MultiDict cookies 记录请求中的cookie信息 Dict headers 记录请求中的请求头 EnvironHeaders method 记录请求使用的HTTP方法 GET/POST url 记录请求的URL地址 string files 记录请求上传的文件 * json 记录请求的json数据 json 响应 Flask 默认支持两种响应方式 数据响应： 默认响应html，也可以返回json 页面响应：重定向 url_for 响应的时候，flask也支持自定义响应状态码 响应html文本 12345## 路由@app.route(\"/\")def index(): # [默认支持]响应html文本 return \"&lt;img src='https://palletsprojects.com/logo-large.png'&gt;\" 返回JSON数据 在flask中可以直接使用jsonify 生成一个json的响应 123456789101112from flask import Flask, request, jsonify@app.route(\"/\")def index(): # 也可以响应json格式代码 data = [ &#123;\"id\":1,\"username\":\"liulaoshi\",\"age\":18&#125;, &#123;\"id\":2,\"username\":\"liulaoshi\",\"age\":17&#125;, &#123;\"id\":3,\"username\":\"liulaoshi\",\"age\":16&#125;, &#123;\"id\":4,\"username\":\"liulaoshi\",\"age\":15&#125;, ] return jsonify(data) 重定向 重定向到站外页面 123456from flask import Flask,request,jsonify,redirect@app.route(\"/\")def index(): # 页面跳转响应 return redirect('http://www.baidu.com') 重定向到自己写的视图函数 也可以直接填写自己的url路径 也可以使用url_for 生成指定视图函数所对应url 1234567891011@app.route(\"/user\")def user(): # 页面跳转响应 userid = None return 'userid %s' % userid## 路由@app.route(\"/\")def index(): # 页面跳转响应 return redirect(url_for('user')) ## 这里的user 是上面的user函数 url_for 12345#使用url_for可以实现视图方法之间的内部跳转# url_for(\"视图方法名\")@app.route(\"/login\")def login(): return redirect( url_for(\"index\") ) 重定向到带有参数的视图函数 在url_for 函数中传入参数 1234567891011## 路由传递参数@app.route(\"/user/&lt;userid&gt;\")def user(userid): # 页面跳转响应 return 'userid %s' % userid# 重定向@app.route(\"/\")def index(): # 使用url_for 生成指定视图函数所对应的url return redirect(url_for('user',userid=100)) 自定义状态码 在flask 中，可以很方便的返回自定义状态码，以实现不符合http协议的状态吗，例如：status code :666 123@app.route('/demo4')def demo4(): return '状态码为 666', 400 会话控制实现状态保持的两种方式： 在客户端存储信息使用Cookie本地存储，token[jwt.,auth] 在服务器端存储信息使用Session，redis 设置Cookieflask框架提供了一个make_responce 函数来快速创建响应对象 12345678## 首先实例化一个make_responce对象，传入的参数是响应对象的主体## 去给这个响应对象设置cookies， 传入key，value，过期时间## 最后将这个对象retrun ge给客户端@app.route(\"/\")def set_cookie(): resp = make_response('this is set cookie') resp.set_cookie('usename','xiaoming',max_age=3600) return resp 获取Cookie1234@app.route(\"/get\")def get_cookie(): resp = request.cookies.get('username') return resp Session 在服务器段进行状态保存的方案就是Session 注意：Session依赖于Cookie，而且flask中使用session，需要配置SECRET_KEY 选项，否则报错 设置session12345678910111213## 首先设置SECRET_KEY class Config(object): SECRET_KEY = '1231fddfds213'app.config.from_object(Config)## 然后从flask中导入session模块from flask import session## 定义视图函数@app.route(\"/set\")def set(): session['uname'] = 'xiaoming' return 'ok' 获取session12345## 直接使用session.get(ket)这个函数取得存储的session@app.route(\"/get\")def get(): resp = session.get('uname') return res 上下文flask中上下文的分为两种上下文：即语境，语意，在程序中可以理解为在代码执行到某一时刻时，根据之前代码所做的操作以及下文即将要执行的逻辑，可以决定在当前时刻下可以使用到的变量，或者可以完成的事情。 Flask中有两种上下文，请求上下文(request context)和应用上下文(application context)。 Flask中上下文对象：相当于一个容器，保存了 Flask 程序运行过程中的一些信息[变量、函数、类与对象等信息] application 指的就是当你调用app = Flask(__name__)创建的这个对象app； request 指的是每次http请求发生时，WSGI server(比如gunicorn)调用Flask.__call__()之后，在Flask对象内部创建的Request对象； application 表示用于响应WSGI请求的应用本身，request 表示每次http请求； application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request 请求上下文对象 request 123Flask的请求上下文，包含请求变量如:method、args、form、values、endpoint、headers、remote_addr都是比较常用的。 例如 ： request.args.get ('user' ) 获取get请求参数 session 1Flask的请求上下文，用于存放用户的会话信息。 应用上下文对象 current_app 1Flask的应用上下文，返回当前app的方法和属性，可以勉强理解为类全局变量。 g 1234 作为Flask 程序全局中的一个临时变量 不同的请求有不同的全局变量g简单来说这个临时变量的生命周期就是一次请求，。 只在当前请求中共享变量 两者区别： 请求上下文：保存了客户端和服务器交互的数据 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等 请求钩子flask的四种请求钩子（又称网络拦截器） before_first_request 在处理第一个请求之前执行（项目初始化的钩子） 应用场景：开启数据库链接，等等 before_request 在每次请求前执行 如果在某修饰函数中返回了一个响应，视图函数将不再被调用 应用场景： 做jwt 或者auth 权限认证， 如果不通过则返回一个响应对象，这样下面的视图函数就不走了。 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象 如果没有抛出错误，在每次请求后执行 接受一个参数： 将视图函数的作出的响应对象传入 在此函数中可以对响对象中的值在返回之前做最后一部修改处理 需要将参数中的响应子啊此参数中进行返回 teardown_request 严格来说，没有固定请求的位置，只有请求上下文被pop出栈的时候就会出发这个，所以即使之前有跑出错误都会执行，通俗一点就是当 在视图内部报错之后执行 接受一个参数： 错误信息，如果有相关错误抛出 需要设置flask的配置DEBUG=False，teardown_request才会接受到异常对象。 可以通过request 方法，进行对请求的url及参数或者文件的提取，再进行逻辑判断，从而决定钩子的流程控制及返回值 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象1234567891011121314## 请求对应的视图函数执行后＝要执行的钩子函数，在返回客户端之前@app.after_requestdef after_request(responce): print('－－－请求执行后需要执行的钩子函数－－－') print('－－－主要作用就是对视图函数返回的值到客户端之前进行再此的修饰－－－') print(responce.data) return responce#路由@app.route(\"/\")def user(): # 页面跳转响应 print('----视图函数-----') return 'ok' teardown_request 当视图中报错时候就会触发teardown请求钩子，必须要一个参数接收异常信息 1234## 在视图内，抛出异常就会执行@app.teardown_requestdef teardown_request(exc): print('exc %s' % exsc ) 异常捕获主动抛出HTTP异常 abort方法 抛出一个给定状态码的HTTPException或者指定响应，列如想要用一个页面未找到异常来终止请求，你可以调用abort(404) 参数： code -HTTP 的错误状态码 12# abort(404)abort(500) 抛出状态码的话，只能抛出HTTP协议的错误状态吗 捕获错误 errorhandler 装饰器 注册一个错误处理程序，当检测到程序抛出指定错误状态吗的时候，就会调用该装饰器所装饰的方法 参数 code_or_exception-HTTP 的错误状态吗或指定异常 例如，统一处理“页面找不到”，状态码为500 ，给用户友好的提示 1234@app.errorhandler(404)def error_404(error): print(error) return \"&lt;img src=https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png &gt;\" 捕获指定异常类型 123@app.errorhandler(ZeroDivisionError)def zero_division_error(e): return '除数不能为0' 实例 1234567891011121314151617181920212223242526272829303132333435from flask import Flaskfrom settings.dev import Config# 创建flask应用app = Flask(__name__)\"\"\"加载配置\"\"\"app.config.from_object(Config)\"\"\"flask中内置了app.errorhander提供给我们捕获异常，实现一些在业务发生错误时的自定义处理。1. 通过http状态码捕获异常信息2. 通过异常类进行异常捕获\"\"\"\"\"\"1. 捕获http异常[在装饰器中写上要捕获的异常状态码也可以是异常类]\"\"\"@app.errorhandler(404)def error_404(e): return \"&lt;h1&gt;您访问的页面失联了！&lt;/h1&gt;\"\"\"\"2. 捕获系统异常或者自定义异常\"\"\"class APIError(Exception): pass@app.route(\"/\")def index(): raise APIError(\"api接口调用参数有误！\") return \"个人中心，视图执行了！！\"@app.errorhandler(APIError)def error_apierror(e): return \"错误: %s\" % eif __name__ == '__main__': app.run(host=\"localhost\",port=8080) Flask-Script扩展安装命令：1pip install flask-script 集成 Flask-Script到flask应用中，创建一个主应用程序，一般我们叫manage.py 配置脚手架使其能通过终端运行项目12345678910111213141516171819202122### 第一步 ，导包from flask_script import Manager### 第二步 初始化manger对象，传入app应用进行绑定manage = Manager(app)### 第三步，就可以使用manage启动运行项目if __name__ == '__main__': manage.run()### 使用终端运行, (main.py 为项目文件)&gt;&gt; python main.py runserver ### 通过 -？ 来获取执行函数的参数&gt;&gt; python main.py runserver -? # 端口和域名不写，默认为127.0.0.1:5000python manage.py runserver# 通过-h设置启动域名，-p设置启动端口python manage.py runserver -h127.0.0.1 -p8080 Flask-Script 可以直接为当前脚本添加新的命令1234567891011#第一步，首先引入Command基类from flask_script import Manager,Command# 第二步 , 自定义命令类，继承Command基类，并将要执行的逻辑放到run方法里面class Hello(Command): \"\"\"run方法里面存放着要执行的逻辑\"\"\" def run(self): print('123')# 第三步，注册自定义命令类并加上别名manage.add_command('hello', Hello() ) 注意，如果有自定义的其他参数传入，需要使用init构造函数导入 Jinja2模板引擎flask中内置的模板语言，设计思想来源与django中的模板引擎,flask 内置的render_template 函数封装了这个模板引擎 要想在flask中使用模板引擎，需要做以下设置 12345678910#首先在创建flask 应用的时候加上 template_folder 参数，指定模板的根目录app = Flask(__name__,template_folder = 'templates')## 默认是在项目的根目录下的## 在视图函数中设置渲染模板设置模板数据from flask import render_template @app.route('/index')def inde(): return render_template('index.html',title='我的flask 项目') 在视图函数中往janja2 模板传入变量 12345678910111213141516### 视图函数@app.route('/index')def inde(): sts = '这也是一个变量' return render_template('index.html',title='我的flask 项目',sts) ## title就是一个变量, sts 也是 ，这是两种方式，前者是传入已经定义好的变量名，后者是直接变量名加上赋值操作一起做， ### 在模板中使用变量## 使用两个花括号来表示变量名 ，， 这种语法叫做** 变量代码块&#123;&#123;&#125;&#125; &#123;&#123; title &#125;&#125;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Jinja2 模板中的变量代码块可以是任何python类型后者对象，只要它能够被python的\\str__魔术方法 或者str() 方法转换成字符串就可以，通俗来说只要能被json的对象都可以。 在模板中怎样注释变量 1&#123;# &#123;&#123; name &#125;&#125; #&#125; jinja2模板内置的变量和函数 就是说你可以在模板中直接访问flask内置的函数和对象 Config 你可以直接在模板中访问flask中的config对象 1&lt;h5&gt;&#123;&#123;config.DEBUG&#125;&#125;&lt;/h5&gt; request 注意： 是当前请求的request对象 12&lt;h5&gt;&#123;&#123;request.url&#125;&#125;&lt;/h5&gt;http://127.0.0.1:5000/index session flask中的session对象 12&#123;&#123; session.new&#125;&#125;False g 变量 在视图函数中设置的g变量的name属性的值，然后在模板中可以取出 由于g变量的特性，所以它也只能取到本次请求所携带的g变量的值 1&#123;&#123; g.name &#125;&#125; url_for() url_for 会根据传入的路由器函数名，返回改路由对应的URL，在模板中始终使用url_for() 就可以安全的修改路由绑定的URL，则不必担心模板中渲染出错的链接： 12345678## 显示 flask中方法函数对应的路由url地址&#123;&#123;url_for('home')&#125;&#125;&gt;&gt; /## 当有路由函数需要传入参数时，这是我们也需要传入参数就可以将完整url拼接出来&#123;&#123; url_for('user', userid=1)&#125;&#125;&gt;&gt; /user/1 流程控制 主要包含两个，（与django中的基本保持一致） 12 - if /else /endif- for /endfor 过滤器 常用的过滤器 过滤器名 说明 safe 渲染时不转义 capitalize 把值的首字母转换成大写，其他字母转换成小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格都去掉 striptags 渲染前把值中的所有的HTML标签都删掉 123## safe 过滤器 ,因为默认的安全机制会对html代码字符串进行转码。不让其正常进行渲染。&#123;&#123; index | safe &#125;&#125; 在jinja2 中， 过滤器是可以直接链式调用的1&#123;&#123;\"hello world \" | reverse | uppper &#125;&#125; 链式调用安装 github 可以当做静态资源仓库，调用的url为12345678910https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png### 这是仓库的url，（可以查看内容的）https://raw.githubusercontent.com/chenluzhong150394 https://raw.githubusercontent.com/chenluzhong150394/img/master/11.png lsof -i:8080 linux 查看端口","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.clz.cloud/categories/Python/"}],"tags":[{"name":"flask框架","slug":"flask框架","permalink":"https://blog.clz.cloud/tags/flask框架/"}]},{"title":"Shadowsocet配置多端口","slug":"shadowscoket 配置多端口 (需要配置防火墙)","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:18:04.135Z","comments":true,"path":"2019/08/10/shadowscoket 配置多端口 (需要配置防火墙)/","link":"","permalink":"https://blog.clz.cloud/2019/08/10/shadowscoket 配置多端口 (需要配置防火墙)/","excerpt":"","text":"shadowscoket 配置多端口 (需要配置防火墙)先将要设置的端口在firewall防火墙放行 12firewall-cmd --zone=public --add-port=52300/tcp --permanent firewall-cmd --zone=public --add-port=52300/udp --permanent 查看firewall 开放的所有端口 1firewall-cmd --zone=public --list-ports 然后去将原来的shadowscoket配置文件进行备份 1cp /etc/shadowsocks.json /etc/shadowsocks.json.bak 然后打开配置文件替换成以下内容 1vim /etc/shadowsocks.json 1234567891011121314&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;&quot;52300&quot;:&quot;chenshuo003&quot;,&quot;52500&quot;:&quot;chenshuo003&quot;&#125;,&quot;obfs&quot;:&quot;plain&quot;,&quot;obfs_param&quot;:&quot;&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125; 然后重启shadowsocket服务并查看状态 1234# 重启服务/etc/init.d/shadowsocks restart## 查看服务状态/etc/init.d/shadowsocks status 重启锐速 12345## 重启锐速service serverSpeeder restart##查看锐速状态service serverSpeeder status 查看当前端口有多少IP链接(脚本有后台,需要手动禁止ip–hosts.deny) 使用netstat 命令 1netstat -anp | grep 52300 找到链接的ip,只要不是自己的,全部禁了 1234### 打开hosts.deny文件vim /etc/hosts.deny ### 将想要禁止的ip添加上去125.23.223.2 然后重启网卡服务,使hosts.deny文件生效 1systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.clz.cloud/categories/Linux/"}],"tags":[{"name":"Shadowsocet","slug":"Shadowsocet","permalink":"https://blog.clz.cloud/tags/Shadowsocet/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-10T03:46:53.049Z","updated":"2019-08-10T03:46:53.049Z","comments":true,"path":"2019/08/10/hello-world/","link":"","permalink":"https://blog.clz.cloud/2019/08/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"celery中停止执行task","slug":"celery中停止执行task","date":"2019-07-06T09:26:24.000Z","updated":"2019-08-10T03:21:14.317Z","comments":true,"path":"2019/07/06/celery中停止执行task/","link":"","permalink":"https://blog.clz.cloud/2019/07/06/celery中停止执行task/","excerpt":"","text":"原因因为最近项目需求中需要提供对异步执行任务终止的功能，所以在寻找停止celery task任务的方法。这种需求以前没有碰到过，所以，只能求助于百度和google，但是找遍了资料，都没找到相关的能停止celery task任务的方法(网上找到的一个方法实测不能用，可能是celery版本的原因，我的项目目前使用的是celery 4.0.2) 解决过程由于网上找不到解决办法，于是只能自己想办法了。想到celery 管理工具flower里面好像有停止celery task的功能，于是去找flower的源码，找到接口的源码如下: 1234logger.info(\"Revoking task '%s'\", taskid)terminate = self.get_argument('terminate', default=False, type=bool)self.capp.control.revoke(taskid, terminate=terminate)self.write(dict(message=\"Revoked '%s'\" % taskid)) 核心代码是self.capp.control.revoke 想到去celery里面找寻revoke函数，发现有两处比较可疑，第一个是celery.worker.control.revoke，第二个是celery.app.control.Control.revoke，直觉来看，应该是第二个方法，但是第二个方法是在一个类里面的，要调用这个方法首先需要获取到celery app的实例，后来去celery 配置里面找，发现在init.py文件里面有__all__ = [&#39;celery_app&#39;]这么一句，于是找到突破点了，引用这个包就能获取到celery_app了。 12from test.ceyery_proj import celery_appcelery_app.control.revoke(task_id, terminate=True) 通过这个方法就能终止正在执行的task，至于task_id在执行任务的时候返回了，我将这个id存储在数据库中，这样就可以被拿来控制task的执行了。 写这篇文档的目的主要是帮助小伙伴们不要再踩这个坑了，也为celery提供一点文档补充吧。","categories":[{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/categories/python/"}],"tags":[{"name":"celery","slug":"celery","permalink":"https://blog.clz.cloud/tags/celery/"},{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/tags/python/"}]},{"title":"websocket翻译","slug":"websocket翻译","date":"2019-07-06T08:57:25.000Z","updated":"2019-08-10T03:21:14.317Z","comments":true,"path":"2019/07/06/websocket翻译/","link":"","permalink":"https://blog.clz.cloud/2019/07/06/websocket翻译/","excerpt":"","text":"rfc6455 websocket中文翻译翻译自： http://tools.ietf.org/rfc/rfc6455.txt InternetEngineering Task Force (IETF) I. FetteRequest forComments: 6455 Google,Inc.Category: StandardsTrack A.MelnikovISSN: 2070-1721Isode Ltd. December2011 WebSocket协议摘要WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。用于这个的安全模型是以origin为基础的安全模型，一般被浏览器使用。协议包含打开握手，其次是基本消息框架，在TCP之上。这项技术的目的是为基于浏览器的、需要与服务器双向通信的应用程序提供一种不依赖于打开多个HTTP连接的机制（例如，使用XMLHttpRequest或&lt;iframe&gt; 和长轮询）。 本备忘录的状态这是一个Internet标准跟踪文件。 这个文档是因特网工程师任务组（IETF）的一个产品。它代表了IETF社区的共识。它已接受公众审查，因特网工程指导组（IESG）证明可出版。关于互联网标准的进一步信息在RFC5741的第2章节。 关于本文档当前状态的信息、勘误表和如何提供反馈，可以在http://www.rfc-editor.org/info/rfc6455找到。 版权声明Copyright (c) 2011 IETF Trust and thepersons identified as the document authors. All rights reserved. This document is subject to BCP 78 and theIETF Trust’s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info )in effect on the date of publication of this document. Please review thesedocuments carefully, as they describe your rights and restrictions with respectto this document. Code Components extracted from this document must includeSimplified BSD License text as described in Section 4.e of the Trust LegalProvisions and are provided without warranty as described in the Simplified BSDLicense. 介绍 背景这部分是不规范的。 历史上，创建需要在客户端和服务器间双向通信的网络应用程序（如即时消息和游戏程序）要求滥用HTTP来轮询服务器来获得更新，通过不同HTTP请求来发送上行通知。 这导致各种问题：l 服务器被迫为每个客户端使用一些不同的底层TCP连接：一个用来向客户端发送消息，为每个到来的消息使用一个新的。l 通信（wire）协议具有很高的开销，因为每个客户端到服务器的消息有HTTP头。l 客户端侧的脚本被迫维护输出连接到输入连接的映射来追踪响应。 一个简单的解决方法是为双向传输使用单一的TCP连接。这是WebSocket协议提供的。结合WebSocket API（WSAPI），它为web页面到远程服务器的双向通信提供了HTTP轮询的替代方案。 同样的技术也可用于各种web应用程序：游戏，股票行情，多用户协同编辑的应用程序，用户界面实时展示服务器侧服务等。 WebSocket协议设计用来取代使用HTTP作为传输层的双向通信技术，并从现有的基础设施（代理、过滤、认证）受益。这些技术作为效率与可靠性的平衡而实现，因为HTTP最初并不是用于双向通信的（见RFC6202有多更讨论）。WebSocket尝试解决在现有HTTP基础设施的环境下现有HTTP双向通信技术的目标；像这样，它设计来工作于HTTP 80、443端口上，并支持HTTP代理和中间设施，即使这意味着增加现有环境的一些复杂性。然后，设计并没有将WebSocket局限于HTTP，未来的实现可以在特定的端口上使用更简单的握手，而不需要重新发明整个协议。最后一点是重要的，因为交互式消息的传输模式并不紧密符合标准的HTTP传输，会在一些部件上引起异常的负载。 1.2. 协议概览这部分是不规范的。 WebSocket 协议有两部分：握手和数据传输。 来自客户端的握手开起来像下面：GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 来自服务器的握手开起来像下面：HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 来自客户端的引导行遵从Request-Line格式，来自服务器的引导行遵从Status-Line格式。Request-Line和Status-Line 在[RFC2616]定义。 在两种情况下，引导行后面跟着一组未排序的头域。这些头域的意义在本文档的第4章指定。额外的头域也可能出现，如cookie [RFC6265]。头的格式和解析在[RFC2616]定义。 一旦客户端和服务器都发送了他们的握手，如果握手成功，传输数据部分开始。这是一个双向传输通道，每个端都能独立、随意发送数据。 在成功握手后，客户端和服务器来回传输数据是以消息message为概念单位的。在传输介质上（on the wire），一个消息由一个或多个帧frame组成。WebSocket消息不需要对应到特定网络层的帧，因为分帧后的消息可能被中间设施合并或拆分。 一帧都有一个关联的类型。属于同一个消息的帧拥有相同的数据类型，广义地说，有文本数据（解释为UTF-8[RFC3629]文本）、二进制数据（它的解释留给了应用程序）和控制帧（不打算携带应用数据，携带的是协议层的信号，如连接关闭信号）类型。这个版本的协议定义了6种帧类型，并保留了10种为以后使用。 1.3. 打开握手这部分是不规范的。 打开握手为了兼容基于HTTP的服务器端软件和中间设施，使同一个端口能够接受HTTP客户端和WebSocket客户端，为了这个目的，WebSocket客户端的握手是HTTP请求的升级。GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 为了兼容[RFC2616]，客户端握手里的头域可能以任意的顺序发送，因此不同头域接收到的顺序是不重要的。 GET方法[RFC2616]的Request-URI用于识别WebSocket连接的终端，允许一个IP地址服务多个域domain，和允许单个服务器提供多个WebSocket终端。 客户端在握手的Host头域里包含主机名，这样，客户端和服务器能够验证他们同意使用哪个主机。额外的头域用于选择WebSocket协议的选项。此版本中典型的可用选项有子协议选择器Sec-WebSocket-Protocol，Sec-WebSocket-Protocol列出客户端支持的扩展，Origin头域等等。Sec-WebSocket-Protocol请求头域可用来表明客户端可接受的子协议（WebSocket协议之上的应用程序层协议）。服务器选择一个或零个可接受的协议，输出到它的握手，来指明它选择了那个协议。Sec-WebSocket-Protocol: chat Origin 头域（RFC6454）用于保护WebSocket服务器不被未授权的运行在浏览器的脚本跨源使用WebSocket API。如果服务器不想接受来自这个源的连接，它可以拒绝连接，并发送一个合适的HTTP错误码。这个头域有浏览器客户端发送；对于非浏览器客户端，这个头域可能发送，如果它在客户端上下文环境中有意义。 最后，服务器得向客户端证明它接收到了客户端的WebSocket握手，为使服务器不接受非WebSocket连接。这防止攻击者通过XMLHttpRequest发送或表单提交精心构造的包来欺骗WebSocket服务器。 为了证明握手被接收，服务器把两块信息合并来形成响应。第一块信息来自客户端握手头域Sec-WebSocket-Key，如Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==对于这个头域，服务器取头的值（由于出现在头域，例如，base64编码[RFC4648]后的版本，消除任何前面后面的空白符），以字符串的形式拼接全局唯一的（GUID，[RFC4122]）标识：258EAFA5-E914-47DA-95CA-C5AB0DC85B11，此值不大可能被不明白WebSocket协议的网络终端使用。然后进行SHA-1 hash（160位）编码，再进行base64编码，将结果作为服务器的握手返回。 具体如下：请求头：Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==取值，字符串拼接后得到：”dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11”;SHA-1后得到： 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb20xbe 0xc4 0xeaBase64后得到： s3pPLMBiTxaQ9kYGzzhZRbK+xOo=最后的结果值作为响应头Sec-WebSocket-Accept 的值。 来自服务器的握手比客户端的简单很多。首先是HTTP 状态行，状态码是101：HTTP/1.1 101 Switching Protocols任何非101的状态码表示WebSocket握手还没有完成，HTTP语义仍然生效。 Connection和Upgrade头域完成HTTP升级。Sec-WebSocket-Accept头表明服务器是否愿意接受连接。如果有，值必须是前面提到的算法得到的值，否则不能解释为服务器接受连接。HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 这些字段由WebSocket客户端为脚本页面检测，如果Sec-WebSocket-Accept的值不符合预期的值，如果头缺失， 或HTTP状态码不是101，连接不会建立，WebSocket帧不会发送。 还可以包含一些可选字段。在协议的这个版本里，主要的可选字段是Sec-WebSocket-Protocol，表示服务器选择的子协议。WebSocket客户端验证服务器选择了一个客户端握手中指定的值。支持多个子协议的服务器必须确保它选择了一个基于客户端握手并在它自己的握手里指定了它。 服务器也可以设置cookie有关的可选头。 1.4. 关闭握手这部分是不规范的。 关闭握手远比打开握手简单。 任何一端都可以发送带有指定控制序号的数据的帧来开始关闭握手（详细在5.5.1节）。当接收到这样的帧时，如果还没有发送，另一端发送一个关闭帧（B）作为响应。当接收到那个（B）帧时，第一个端关闭连接，因为知道没有更多的数据需要传输。 发送表明关闭连接的控制帧后，端不应该再发数据；接收到表示应该关闭连接的控制帧后，端丢弃后面接收的所有数据。 两端都可以安全地同时开始关闭握手。 这个关闭握手想补充TCP的关闭握手（FIN/ACK），依据是，TCP关闭握手不总是端到端可靠的，特别是出现拦截代理和其他的中间设施。 通过发送一个关闭帧并等待返回关闭帧响应，可以避免一些数据丢失的特殊情况。例如，在一些平台上，如果一个套接字关闭时有数据在接收队列，RST包发送后，将导致recv()失败，因为接收到RST，即使仍有数据等待读取。 1.5. 设计哲学这部分是不规范的。 WebSocket协议的设计原则就是最小化框架（唯一的框架就是协议是基于帧的，而不是基于流的，并且支持区分Unicode文本和二进制帧的）。它希望元数据放在WebSocket上面的应用程序层。 概念上，WebSocket确实只是TCP上面的一层，做下面的工作：l 为浏览器添加web 的origin-based的安全模型。l 添加定位和协议命名机制来支持在同一个端口上提供多个服务和同一个IP上有多个主机名。l 在TCP上实现帧机制，来回到IP包机制，而没有长度限制。l 在带内包含额外的关闭握手，是为了能在有代理和其他中间设施的地方工作。 除了这些，WebSocket没有再添加任何东西。基本上，它想尽可能暴露原始的TCP给脚本，又给web约束。它还设计以这样的方式，它的服务器能和HTTP服务器共享同一个端口，通过使它的请求是一个合法的HTTP升级请求。在概念上可以使用其他的协议来建立客户端-服务器消息机制，但WebSocket的目的是提供一个相当简单的协议，能够与HTTP和已部署的HTTP基础设施共存（如代理），尽可能接近TCP，通过给定安全模型在现有基础设施上安全使用，伴随简化使用和使简单事情保持简单的额外目标。 协议考虑到可扩展，未来的版本很可能引入额外的概念，如multiplexing. 1.6. 安全模型这部分是不规范的。 WebSocket协议使用起源模型（origin model），浏览器用来限制哪些网页能够接触WebSocket服务器。当专用的客户端直接使用WebSocket协议时，起源模型没用了，因为客户端能够提供任意的origin字符串。 这个协议目的是不和现有协议（如SMTP、HTTP）的服务器建立连接，如果要求，允许HTTP服务器可选地支持此协议。这个通过一个严格的、精心制作的握手和在握手完成前限制数据进入连接来做到的。 类似地，当其他协议的数据发送到WebSocket时，使连接失败。这主要是通过要求服务器证明它读取了握手，在只有当握手含有适当的部分时，这些部分只能由WebSocket客户端发送。特别是，在写这个规范时，以Sec- 开头的头不能被来自浏览器的攻击者使用HTML和JavaScriptAPI如XMLHttpRequest发送。 1.7. 与TCP和HTTP的关系这部分是不规范的。 WebSocket协议是独立的、基于TCP的协议。与HTTP的唯一关系是它的握手可以被HTTP服务器解释为一个升级请求。 默认地，WebSocket协议为常规连接使用80端口，为基于传输层安全（TLS）的连接使用443端口。 1.8. 建立连接这部分是不规范的。 当一个连接连接到被HTTP服务器共享的端口（对于端口80和443是很可能发生的场景），连接将展示给HTTP服务器的将是一个伴有Upgrade的、常规的GET请求。在只有一个IP地址和单个服务器对应所有传输到单个主机的相对简单的设置，这将允许特殊的方法来部署基于系统的WebSocket协议。在更复杂的设置下，一组用于WebSocket连接的主机从HTTP服务器分离是更容易管理的。在写这篇规范的时候，应当指出，在端口80和443上连接有显著的成功率， 1.9. 使用WebSocket协议的子协议这部分是不规范的。 客户端可以通过在它的握手包含Sec-WebSocket-Protocol头来要求服务器使用指定的子协议。如果指定了，为建立连接，服务器需要包含一个同样的头和一个选择了的子协议在它的响应。 这些子协议的命名要按照11.5节注册。为了避免潜在的冲突，推荐使用带有子协议发起人的域名的ASCII版本号的名字。例如，Excaple集团准备创建一个聊天子协议，由web上的一些服务器来实现，它可以命名为“chat.example.com”。如果Example组织命名他们的竞争子协议为“chat.example.org”，那么两种子协议都能背服务器同时实现，由服务器根据客户端发送的数据动态选择使用子协议。 子协议的版本可以是向后不兼容的，通过改变子协议的名字，如从“bookings.example.net”到“v2.bookings.examples.net”。这些子协议可以认为完全独立于WebSocket客户端的。向后兼容的版本可通过复用同样的协议字符串来实现，但小心设计协议来支持扩展。 一致性要求All diagrams, examples, and notes in thisspecification are nonnormative, as are all sections explicitly markednon-normative. Everything else in this specification is normative. The key words “MUST”, “MUSTNOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,”SHOULD”, “SHOULD NOT”, “RECOMMENDED”,”MAY”, and “OPTIONAL” in this document are to beinterpreted as described in [RFC2119]. Requirements phrased in the imperative aspart of algorithms (such as “strip any leading space characters” or”return false and abort these steps”) are to be interpreted with themeaning of the key word (“MUST”, “SHOULD”, “MAY”,etc.) used in introducing the algorithm. 2.1. Terminology and OtherConventionsASCII shall mean the character-encodingscheme defined in [ANSI.X3-4.1986]. This document makes reference to UTF-8values and uses UTF-8 notational formats as defined in STD 63 [RFC3629]. Key terms such as named algorithms ordefinitions are indicated like this. Names of header fields or variables areindicated like |this|. Variable values are indicated like /this/. This document references the procedure to_Fail the WebSocket Connection_. This procedure is defined in Section 7.1.7. _Converting a string to ASCII lowercase_means replacing all characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATINCAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATINSMALL LETTER Z). Comparing two strings in an ASCIIcase-insensitive manner means comparing them exactly, code point for codepoint, except that the characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATINCAPITAL LETTER Z) and the corresponding characters in therange U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTERZ) are considered to also match. The term “URI” is used in thisdocument as defined in [RFC3986]. When an implementation is required to_send_ data as part of the WebSocket Protocol, the implementation MAY delay theactual transmission arbitrarily, e.g., buffering data so as to send fewer IPpackets. Note that this document uses both [RFC5234]and [RFC2616] variants of ABNF in different sections. WebSocket URI本规范定义了两种URI方案，使用在RFC5234定义的ABNF语法、术语和在RFC3986定义的URI规范的ABNF成果。 ws-URI = “ws:” “//“host [ “:” port ] path [ “?” query ]wss-URI = “wss:” “//“host [ “:” port ] path [ “?” query ]host = &lt;host, defined in [RFC3986],Section 3.2.2&gt;port = &lt;port, defined in [RFC3986],Section 3.2.3&gt;path = &lt;path-abempty, defined in [RFC3986],Section 3.3&gt;query = &lt;query, defined in [RFC3986],Section 3.4&gt; port部分是可选的；ws默认的端口是80，wss默认是443。 如果scheme部分匹配大小写不敏感的“wss”，那么URI就被称作是“安全的”。 “resource-name”可以由下面部分的拼接组成：l “/“ 如果path部分是空的l path部分l ? 如果query部分不为空l 空的query部分 片段（fragment）标识符在WebSocket URI环境是没意义的，不允许在这些URI中使用。与任何的URI方案一样，当字符“#”不表示片段的开始时，必须转义为%23。 打开握手 客户端要求为建立WebSocket连接，客户端打开一个（TCP）连接并发送一个在这个章节里定义的握手。一个连接最初定义为CONNECTING状态。客户端需要提供WebSocket URI的部件：host、port、resource name、和secure标志，这些都是第3章里讨论的WebSocket URI的组件，伴随使用一些协议和扩展。另外，如果客户端是个web浏览器，它提供origin。客户端运行在受限环境，如连接到特定关卡的移动手持设备上的浏览器，可能把连接的管理卸载给另一个网络代理。在这种情况下，用于本规范目的的客户端包括手持设备软件和任意的这类代理。 当客户端准备用建立WebSocket连接，给定的一组（host，port，resource name，secure标记），连同使用一序列协议和扩展，和在浏览器情况下有个origin，它必须打开一个（TCP）连接，发送一个打开握手，从响应里读取服务器的握手。（TCP）连接应该如何打开的准确要求，在打开握手应该发送什么，服务器响应应该如何解释，将在下面的章节里。在下面的文本里，我们将使用使用第3章里的名字，如“/host/”和“/secure/ flag”。 1、传递给这个算法（/host/, /port/, /resource name., and /secure/ flag）的WebSocket URI组件必须是合法的，依照第3章说明的WebSocket URI规范。如果有任何的组件是非法的，客户端必须使WebSocket 连接失败，并中止这些步骤。 2、如果客户端已经有WebSocket 连接到用 /host/ 和 /port/ 对 鉴定的远程主机，即使远程主机有另外的名字，客户端必须等待，直到那个连接已经建立或失败。必须保证不能有超过1个的连接处于CONNECTING状态。如果有多个到同一个IP地址的连接同时尝试，客户端必须串行化他们，使在没有超过1个的连接在同时执行下面的步骤。如果客户端不能确定远程主机的IP地址（例如，所有的通信都是通过一个代理服务器来完成的，代理服务器自己执行DNS查询），为了此步骤的目的，那么客户端必须假设每个主机名指向不同的远程主机，而且，客户端应该限制同时pending的连接数量到一个合理的低的数量（例如，客户端可能允许同时pending的连接到a.example.com和 b.example.com，但如果有30个连接同时要求连接到单个主机，可能是不允许的）。例如，在一个web浏览器环境里，客户端需要考虑用户打开的网页选项卡的数量，来设置同时pending连接的限制数量。注意：这使脚本仅仅通过打开大量到远程主机的WebSocket的连接来实施DNS估计更难了。当服务器受到攻击时，能通过在关闭之前挂起连接来减少负载，因为那将减少客户端重连的速率。注意：客户端到单个远程主机的已建立WebSocket连接的数量是没有限制的。当承受高的负载时，服务器可以拒绝接收来自已经有过多数量连接的hosts/IP地址的连接，或断开耗资源的连接。 3、使用代理：如果客户端配置为使用代理，当使用WebSocket协议连接到/host/和/port/的主机，客户端应当连接到那个代理，告诉它打开一个TCP连接到给定的/host/和/port/的主机。举例：例如，如果客户端对所有传输使用HTTP代理，如果它尝试连接到example.com服务器的端口80，它可能发送下面的行到代理服务器：CONNECT example.com:80 HTTP/1.1Host: example.com如果有密码，连接看起来是这样的：CONNECT example.com:80 HTTP/1.1Host: example.comProxy-authorization: BasicZWRuYW1vZGU6bm9jYXBlcyE=如果客户端没有配置使用代理，一个直接TCP连接应该打开到/host/ 和/port/指定的主机。注意：Implementationsthat do not expose explicit UI for selecting a proxy for WebSocket connectionsseparate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy forWebSocket connections, if available, orfailing that, to prefer the proxy configured for HTTPS connections over theproxy configured for HTTP connections.For the purpose of proxy autoconfigurationscripts, the URI to pass the function MUST be constructed from /host/, /port/,/resource name/, and the /secure/ flag using the definition of a WebSocket URIas given in Section 3.注意：The WebSocketProtocol can be identified in proxy autoconfiguration scripts from the scheme(“ws” for unencrypted connections and “wss” for encryptedconnections). 4、如果（TCP）连接不能打开，因为直接连接失败还是使用的任何代理返回错误，客户端必须使用WebSocket连接失败，并中止连接尝试。 5、如果/secure/是true，客户端必须在（TCP）连接上执行TLS握手，在打开连接后，发送握手数据【RFC2818】之前。如果这个失败了，客户端必须使WebSocket连接失败并中止连接。否则，所有在这条通道上的后续的通信必须使用加密通道【RFC5246】。Clients MUST use the Server Name Indicationextension in the TLS handshake [RFC6066]. 一旦到服务器的（TCP）连接建立（包括通过代理或TLS加密的通道），客户端必须发送一个打开握手到服务器。握手包含一个HTTPUpgrade请求，连同一些必须的和可选的头域。打开握手的要求如下： 握手必须是一个合法的【RFC2616】规定的HTTP请求。 请求的方法必须是GET，HTTP版本必须至少是1.1。例如，如果WebSocketURI是”ws://example.com/chat”，发送的第一行应该是”GET/chat HTTP/1.1”。 请求的Request-URI部分必须符合第3章定义的/resourcename/，或者是绝对的http/httpsURI，当解析后，有个/resourcename/，/host/,/port/，符合对应的ws/wssURI。 请求必须含有Host头域，它的值包含/host/加上可选的”:”后跟/port/（当没使用默认的端口时）。 请求必须包含Upgrade头域，其值必须含有”websocket”关键字。 请求必须含有Connection头域，其值必须含有”Upgrade”记号。 请求必须包含名为Sec-WebSocket-Key的头域，其值必须是nonce组成的随机选择的16字节的被base64编码后的值。必须为每个连接随机选择nonce。注意：例如，如果随机选取的一序列字节值是0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x090x0a0x0b 0x0c 0x0d 0x0e0x0f 0x10，头域的值应该是”AQIDBAUGBwgJCgsMDQ4PEC==”。 如果请求来自浏览器客户端，必须包含名为Origin的头域。如果连接来自非浏览器客户端，请求可能包括这个头域，如果那个客户端的语义符合此处浏览器客户端描述的用例。这个头域的值是建立连接的代码运行环境的origin的ASCII序列。在【RFC6454】有描述此头域值是如何构建的。例如，下载子www.example.com的代码尝试建立连接到ww2.example.com，此头域的值应该是&quot;http://www.example.com&quot;。 请求必须包含名为Sec-WebSocket-Version的头域，其值必须是13。注意：Althoughdraft versions of this document (-09, -10, -11, and -12) were posted (they were mostlycomprised of editorial changesand clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were notused as valid valuesfor Sec-WebSocket-Version. These values were reserved in the IANA registrybut were not and will not be used. 请求可能包含名为Sec-WebSocket-Protocol的头域。如果有，此值指示客户端希望使用的一个或多个逗号分隔的子协议，按优选顺序。组成此值的元素必须是非空字符串，字符范围在U+0021到U+007E，不包括在【RFC2616】定义的分隔符，而且必须是唯一的字符串。此头域值的ABNF是1#token，构建和规则在【RFC2616】定义。 请求可能包含名为Sec-WebSocket-Extensions的头域。如果有，其值指示了客户端希望使用的协议级别的扩展。此头域的解释和格式在9.1节描述。 请求可能包含任意的其他头域。例如cookies和/或认证相关的头域，如Authorization头域。 一旦客户端打开握手发送出去，在发送任何数据之前，客户端必须等待服务器的响应。客户端必须按如下步骤验证响应：1、如果从服务器接收到的状态码不是101，按HTTP【RFC2616】程序处理响应。在特殊情况下，如果客户端接收到401状态码，可能执行认证；服务器可能用3xx状态码重定向客户端（但不要求客户端遵循他们），等等。否则按下面处理。 2、如果响应缺失Upgrade头域或Upgrade头域的值没有包含大小写不敏感的ASCII 值”websocket”，客户端必须使WebSocket连接失败。 3、如果响应缺失Connection头域或其值不包含大小写不敏感的ASCII值”Upgrade”，客户端必须使WebSocket连接失败。 4、如果响应缺失Sec-WebSocket-Accept头域或其值不包含 |Sec-WebSocket-Key |（作为字符串，非base64解码的）+ “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”的base64编码 SHA-1值，客户端必须使WebSocket连接失败。 5、如果响应包含Sec-WebSocket-Extensions头域，且其值指示使用的扩展不出现在客户端发送的握手（服务器指示的扩展不是客户端要求的），客户端必须使WebSocket连接失败。（解析此头域来决定哪个扩展是要求的在第9.1节描述。） 6、如果响应包含Sec-WebSocket-Protocol头域，且这个头域指示使用的子协议不包含在客户端的握手（服务器指示的子协议不是客户端要求的），客户端必须使WebSocket连接失败。 如果服务器响应不遵从4.2.2节和本节定义服务器握手的要求，客户端必须使WebSocket连接失败。 请注意，依据RFC2616，所有HTTP请求和HTTP响应的头域都是大小写不敏感的。 如果服务器的响应符合上面的验证要求，说明WebSocket连接建立，WebSocket连接处于OPEN状态。The Extensions InUse isdefined to be a (possibly empty) string, the value of which is equal to the valueof the |Sec-WebSocket-Extensions| header field supplied by the server’s handshake or the nullvalue if that header fieldwas not present in the server’s handshake. The Subprotocol In Use is defined tobe the value of the |Sec-WebSocket-Protocol| header field in the server’s handshake or thenull value if that headerfield was not present in the server’s handshake. Additionally, if any header fields in theserver’s handshake indicatethat cookies should be set (as defined by [RFC6265]), these cookies are referred to as_Cookies Set During the Server’s Opening Handshake_. 4.2. 服务器端要求服务器可能把连接的管理卸载给其他的网络代理，如负载均衡器和反向代理。在这种情况下，用于此规范目的的服务器被认为包含了服务器端基础设施的所有部分，从第一个终结TCP连接的设备一路直到处理请求并发送响应的服务器。例如：一个数据中心可能有一台服务器用合适的握手来响应WebSocket请求，然后把连接传递给另一台服务器来实际处理数据帧。在本规范的目的中，“服务器”是两台电脑的结合。 4.2.1. 读取客户端打开握手当一个客户端开始WebSocket连接，它发送自己角色的打开握手。服务器必须解析至少部分的握手来获取需要的信息，来生成服务器角色的握手。 客户端握手包含下面的部分。如果服务器在读取握手时，发现客户端发送的握手不符合下面的描述（注意，安装RFC2616，头域的顺序是不重要的），包括但不限于任何违反ABNF语法指定的握手组件，服务器必须停止处理客户端握手，并返回恰当的HTTP响应，如 400 badrequest。验证步骤：1、一个HTTP/1.1或更高的GET请求，包括应该解释为/resourcename/的”Request-URI”（或者是一个绝对的HTTP/HTTPS URI包含/resource name/）。 2、一个Host头域包含服务器的职权（authority）。 3、一个Upgrade头域包含一个ASCII大小写不敏感的值”websocket”。 4、一个Connection 头域包含一个ASCII大小写不敏感的令牌”Upgrade”。 5、一个Sec-WebSocket-Key 头域有一个base64编码的值，解码后是一个16字节长度。 6、一个Sec-WebSocket-Version 头域且值为13。 7、可选的一个Origin头域。此头域由所有的浏览器客户端发送。缺少这个头域的连接不应该解释为来自浏览器客户端。 8、可选的一个Sec-WebSocket-Protocol 头域，有一序列的值，表示客户端希望用来交流的协议，按优选排序。 9、可选的一个Sec-WebSocket-Extensions头域。有一序列的值，表示客户端希望用来交流的扩展，按优选排序。此头域的解释在9.1节讨论。 10、可选的其他头域，用于发送cookie或请求认证到服务器。按RFC2616，未知的头域将被忽略。 4.2.2. 发送服务器打开握手当客户端建立一个到服务器的WebSocket连接，服务器必须完成下面的步骤来接受连接，并发送服务器打开握手。 1、如果连接在HTTPS（HTTP-over-TLS）端口上打开，在连接上执行TLS握手。如果失败了，关闭连接；否则，连接的所有后续的通信（包括服务器握手）必须在加密的通道上进行。 2、服务器可以执行额外的客户端验证，例如，通过返回401状态码和相应的|WWW-Authenticate|头域。 3、服务器可能用3xx状态码来重定向客户端。注意，这个步骤可以和上面描述的认证步骤 一起、之前或之后发生。 4、建立下面的信息：/origin/客户端握手的|Origin|头域指示了建立连接的脚本的起源。起源被序列化为ASCII，并转换为小写。服务器可能使用这个信息来作为决定是否接收连接的部分因素。如果服务器不能验证起源，它将接收来自任何地方的连接。如果服务器不想接收这个连接，它必须返回合适的HTTP错误码（如403Forbidden），并中止WebSocket握手，按本节的描述。更多细节，见第10章。 /key/客户端握手的|Sec-WebSocket-Key|包含一个base64编码的值，如果解码，将是16字节长度。此值（编码后的）用于创建服务器握手，来指示接收连接。服务器没有必要base64解码此值。 /version/客户端握手的|Sec-WebSocket-Version|包含WebSocket协议的版本，客户端用这个来尝试通信。如果这个版本不符合服务器能理解的版本，服务器必须中止WebSocket握手，发送一个合适HTTP错误码（如426 Upgrade Required），且有一个|Sec-WebSocket-Version|头域来指示服务器能够理解的版本。 /resource name/一个用于服务器提供的服务的标识符。如果服务器提供了多个服务，值应该能从resourcename推断得到，从给定客户端握手的GET方法的”Request-URI”。如果请求的服务不可得，服务器必须发送合适的HTTP错误码（如404 Not Found），并中止WebSocket握手。 /subprotocol/或者是空，或者是单个值表示服务器准备使用的子协议。值的选择必须从客户端握手推断得到，具体是从|Sec-WebSocket-Protocol|选择一个值，服务器将用于这个连接的。如果客户端握手不包含这样1个头域或者服务器不同意使用客户端请求的子协议，唯一可接受的值是null。没有这个域等价于null值（意味着如果服务器不打算使用任何推荐的子协议，它必须不发送回一个|Sec-WebSocket-Protocol|头域在它的响应里）。在这个目的上，Empty字符串不同于null值，且不是这个域的合法值。用于此头域值的ABNF是（token），构建和规则在RFC2616定义。 /extensions/一个（可能空的）列表表示服务器准备使用的协议级扩展。如果服务器支持多个扩展，那么值必须从客户端握手推断得到，具体是从|Sec-WebSocket-Extensions|域选择一个或多个值。此域的缺失等价于null值。在这个目的上，Empty字符串不同于null值。没有列在客户端的扩展必须不被登记。选择和解释这些值的方法在9.1节讨论。 5、如果服务器选择接受连接，必须返回一个合法的HTTP响应，指示下面： 一个状态行，有101响应码，按照RFC2616。这样一个响应看起来是这样：“HTTP/1.1 101 Switching Protocols” 一个Upgrade 头域，值为”websocket”，按照RFC2616。 一个Connection头域，值为”Upgrade”。 一个Sec-WebSocket-Accept 头域。The value of this header field is constructed by concatenating /key/, defined above instep 4 in Section 4.2.2,with the string “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”,taking the SHA-1 hash of this c oncatenated value to obtain a 20-bytevalue and base64-encoding (see Section 4 of [RFC4648]) this 20-byte hash. The ABNF [RFC2616] of this header field is defined as follows:Sec-WebSocket-Accept= base64-value-non-emptybase64-value-non-empty= (1*base64-data [ base64-padding ]) |base64-paddingbase64-data= 4base64-characterbase64-padding= (2base64-character “==”) |(3base64-character”=”)base64-character= ALPHA | DIGIT | “+” | “/“ NOTE: As an example, if the value of the|Sec-WebSocket-Key| header field in the client’s handshake were “dGhlIHNhbXBsZSBub25jZQ==”, the serverwould append the string “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” toform the string”dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CAC5AB0DC85B11”. Theserver would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c0xc0 0x62 0x4f 0x16 0x900xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is thenbase64-encoded, to give the value “s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”,which would be returned in the |Sec-WebSocket-Accept| header field. 可选的一个Sec-WebSocket-Protocol 头域，其值/subprotocol/在4.2.2节步骤4定义。 可选的一个Sec-WebSocket-Extensions 头域，其值/extensions/在4.2.2节步骤4定 义。如果使用多个extension，可以在罗列单个Sec-WebSocket-Extensions 头域，也 可以分割在多个Sec-WebSocket-Extensions 。 这完成了服务器握手。如果服务器完成这些步骤，且没有终止WebSocket握手，服务器认为WebSocket连接已建立，那么WebSocket连接处于OPEN状态。在此时，服务器可能开始发送（和接收）数据。 4.3. Collected ABNF for New HeaderFields Used in HandshakeThis section isusing ABNF syntax/rules from Section 2.1 of[RFC2616], including the “implied *LWS rule”. Note that thefollowing ABNF conventions are used in this section.Some names of therules correspond to names of the correspondingheader fields. Suchrules express values of the corresponding headerfields, forexample, the Sec-WebSocket-Key ABNF rule describes syntaxof the|Sec-WebSocket-Key| header field value. ABNF rules with the“-Client”suffix in the name are only used in requests sent by theclient to theserver; ABNF rules with the “-Server” suffix in thename are only usedin responses sent by the server to the client.For example, theABNF rule Sec-WebSocket-Protocol-Client describessyntax of the|Sec-WebSocket-Protocol| header field value sent by theclient to the server. The following newheader fields can be sent during the handshake fromthe client to the server:Sec-WebSocket-Key= base64-value-non-emptySec-WebSocket-Extensions= extension-listSec-WebSocket-Protocol-Client= 1#tokenSec-WebSocket-Version-Client= versionbase64-value-non-empty= (1*base64-data [ base64-padding ]) |base64-paddingbase64-data= 4base64-characterbase64-padding= (2base64-character “==”) |(3base64-character”=”)base64-character= ALPHA | DIGIT | “+” | “/“extension-list= 1#extensionextension= extension-token *( “;” extension-param )extension-token= registered-tokenregistered-token =tokenextension-param= token [ “=” (token | quoted-string) ];When using the quoted-string syntax variant, the value;after quoted-string unescaping MUST conform to the;’token’ ABNF.NZDIGIT= “1” | “2” | “3” | “4” | “5”| “6” |“7”| “8” | “9”version= DIGIT | (NZDIGIT DIGIT) |(“1”DIGIT DIGIT) | (“2” DIGIT DIGIT);Limited to 0-255 range, with no leading zeros The following newheader fields can be sent during the handshake fromthe server to the client:Sec-WebSocket-Extensions= extension-listSec-WebSocket-Accept= base64-value-non-emptySec-WebSocket-Protocol-Server= tokenSec-WebSocket-Version-Server= 1#version 4.4. 支持多版本的WebSocket协议This sectionprovides some guidance on supporting multiple versionsof the WebSocket Protocol in clients and servers. Using the WebSocketversion advertisement capability (the|Sec-WebSocket-Version|header field), a client can initially requestthe version of theWebSocket Protocol that it prefers (which doesn’tnecessarily have tobe the latest supported by the client). If theserver supports therequested version and the handshake message isotherwise valid,the server will accept that version. If the serverdoesn’t support therequested version, it MUST respond with a|Sec-WebSocket-Version|header field (or multiple|Sec-WebSocket-Version|header fields) containing all versions it iswilling to use. Atthis point, if the client supports one of theadvertisedversions, it can repeat the WebSocket handshake using anew version value. The followingexample demonstrates version negotiation describedabove:GET/chat HTTP/1.1Host:server.example.comUpgrade:websocketConnection:Upgrade…Sec-WebSocket-Version:25 The response from the server might look as follows:HTTP/1.1400 Bad Request…Sec-WebSocket-Version:13, 8, 7 Note that the last response from the server might also look like:HTTP/1.1400 Bad Request…Sec-WebSocket-Version:13Sec-WebSocket-Version:8, 7 The client now repeats the handshake that conforms to version 13:GET/chat HTTP/1.1Host:server.example.comUpgrade:websocketConnection:Upgrade…Sec-WebSocket-Version:13 数据成帧 概述在WebSocket协议，数据是用一序列帧来传输。为了避免使网络中间设施（如拦截代理）混乱和安全原因（更多讨论在10.3节），客户端必须标记所有发往服务器的帧（更多细节在5.3节）。（注意，进行标记是不管WebSocket协议是否使用了TLS。）当服务器接收到一个没有标记的帧时必须关闭连接。在这种情况下，服务器可能发送一个有状态码1002（协议错误）的关闭帧，如7.4.1节定义。服务器必须不标记它发给客户端的任何帧。客户端必须关闭连接，如果它检测到标记了的帧。在这种情况下，它可能使用1002状态码（协议错误）。（这些规则在未来的规范中可能放松。） 基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的”Extension data”和”Application data”，统称为”Payload data”。保留了一些特殊位和操作码供后期扩展。 在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送（见5.5.1节）。 5.2. 基本的帧协议用于数据传输部分的有线格式用ABNF描述，细节在本节。（注意，不像本文档中的其他章节，本节的ABNF是作用于一组比特位上。每组比特位的长度在注释里指示。当在有线上编码后，最重要的比特的最左边的ABNF）。帧的一个高层概览见下图。当下图与ABNF有冲突时，图是权威的。FIN： 1bit表示此帧是否是消息的最后帧。第一帧也可能是最后帧。RSV1，RSV2，RSV3： 各1bit必须是0，除非协商了扩展定义了非0的意义。如果接收到非0，且没有协商扩展定义 此值的意义，接收端必须使WebSocket连接失败。Opcode： 4bit定义了”Payloaddata”的解释。如果接收到未知的操作码，接收端必须使WebSocket 连接失败。下面的值是定义了的。%x0 表示一个后续帧%x1 表示一个文本帧%x2 表示一个二进制帧%x3-7 为以后的非控制帧保留%x8 表示一个连接关闭%x9 表示一个ping%xA 表示一个pong%xB-F 为以后的控制帧保留 Mask： 1bit定义了”Payload data”是否标记了。如果设为1，必须有标记键出现在masking-key，用 来unmask “payload data”，见5.3节。所有从客户端发往服务器的帧必须把此位设为1。 Payload length： 7bit, 7 + 16bit, 7 + 64bit“Payloaddata”的长度，字节单位。如果值是0-125，则是有效载荷长度。如果是126， 接下来的2字节解释为16位无符号整数，作为有效载荷长度。如果127，接下来的8 字节解释为64位无符号整数（最高位必须是0），作为有效载荷长度。多字节长度数值 以网络字节序表示。注意，在任何情况下，必须用最小数量的字节来编码长度，例如， 124字节 长的字符串不能编码为序列126, 0, 124。有效载荷长度是”Extension data”的长 度加上”Application data”的长度。”Extension data”的长度可能是0，在这种情况下， 有效载荷长度是”Applicationdata”的长度。 Masking-key：0或4字节所有从客户端发往服务器的帧必须用32位值标记，此值在帧里。如果mask位设为1， 此字段（32位值）出现，否则缺失。更多的信息在5.3节，客户端到服务器标记。 Payload data： (x + y)字节“Payloaddata” 定义为”extensiondata” 后接”application data”。 Extension data： x 字节“Extensiondata”是0字节，除非协商了扩张。所有扩张必须指定”extensiondata”的长度， 或者如何计算长度，如何使用扩展必须在打开握手时进行协商。如果有，”Extension data”包括在有效载荷长度。 Application data： y字节任意”Applicationdata”占据了帧的剩余部分，在”Extensiondata”之后。 “Applicationdata”的长度等于有效载荷长度减去”Extensiondata”的长度。 The base framingprotocol is formally defined by the following ABNF[RFC5234]. It isimportant to note that the representation of thisdata is binary, notASCII characters. As such, a field with a lengthof 1 bit that takesvalues %x0 / %x1 is represented as a single bitwhose value is 0 or1, not a full byte (octet) that stands for thecharacters”0” or “1” in the ASCII encoding. A field with a lengthof 4 bits withvalues between %x0-F again is represented by 4 bits,again NOT by anASCII character or full byte (octet) with thesevalues. [RFC5234]does not specify a character encoding: “Rulesresolve into astring of terminal values, sometimes calledcharacters. InABNF, a character is merely a non-negative integer.In certaincontexts, a specific mapping (encoding) of values into acharacter set (suchas ASCII) will be specified.” Here, thespecified encodingis a binary encoding where each terminal value isencoded in the specified number of bits, which varies for each field. ws-frame =frame-fin ; 1 bit in lengthframe-rsv1; 1 bit in lengthframe-rsv2; 1 bit in lengthframe-rsv3; 1 bit in lengthframe-opcode; 4 bits in lengthframe-masked; 1 bit in lengthframe-payload-length; either 7, 7+16,;or 7+64 bits in;length[frame-masking-key ] ; 32 bits in lengthframe-payload-data; n*8 bits in;length, where;n &gt;= 0frame-fin = %x0 ;more frames of this message follow/%x1 ; final frame of this message;1 bit in lengthframe-rsv1 = %x0 /%x1;1 bit in length, MUST be 0 unless;negotiated otherwiseframe-rsv2 = %x0 /%x1;1 bit in length, MUST be 0 unless;negotiated otherwiseframe-rsv3 = %x0 /%x1;1 bit in length, MUST be 0 unless;negotiated otherwiseframe-opcode =frame-opcode-non-control /frame-opcode-control/frame-opcode-contframe-opcode-cont =%x0 ; frame continuationframe-opcode-non-control=%x1 ; text frame/%x2 ; binary frame/%x3-7;4 bits in length,;reserved for further non-control framesframe-opcode-control= %x8 ; connection close/%x9 ; ping/%xA ; pong/%xB-F ; reserved for further control; frames; 4 bits in length frame-masked = %x0;frame is not masked, no frame-masking-key/%x1;frame is masked, frame-masking-key present;1 bit in lengthframe-payload-length= ( %x00-7D )/( %x7E frame-payload-length-16 )/( %x7F frame-payload-length-63 );7, 7+16, or 7+64 bits in length,;respectivelyframe-payload-length-16= %x0000-FFFF ; 16 bits in lengthframe-payload-length-63= %x0000000000000000-7FFFFFFFFFFFFFFF;64 bits in lengthframe-masking-key =4( %x00-FF );present only if frame-masked is 1;32 bits in lengthframe-payload-data= (frame-masked-extension-dataframe-masked-application-data);when frame-masked is 1/(frame-unmasked-extension-dataframe-unmasked-application-data);when frame-masked is 0frame-masked-extension-data= ( %x00-FF );reserved for future extensibility;n8 bits in length, where n &gt;= 0frame-masked-application-data= ( %x00-FF );n8 bits in length, where n &gt;= 0frame-unmasked-extension-data= ( %x00-FF );reserved for future extensibility;n8 bits in length, where n &gt;= 0frame-unmasked-application-data= ( %x00-FF ); n8bits in length, where n &gt;= 0 5.3. 客户端到服务器标记被标记的帧必须设置frame-masked域为1，如5.2节定义。标记键必须作为frame-masking-key完整包含在帧里，作为frame-masking-key，如5.2节定义。它用于标记”Payload data”。 标记键是由客户端随机选择的32位值。准备标记帧时，客户端必须从一组允许的32位值选择一个新的标记键。标记键应该是不可预测的，因此，标记键必须推断自强源的熵（strong source of entropy），给定帧的标记键必须不能简单到服务器或代理可以预测标记键是用于一序列帧的。不可预测的标记键是阻止恶意应用的作者从wire上获取数据的关键。RFC 4086 discusses what entails a suitable source of entropy forsecurity-sensitive applications. 标记不影响”Payloaddata”的长度。为了把标记数据转换为非标记数据，或反转，下面的算法将被应用。同样的算法将应用，而不管转换的方向，例如同样的步骤将用于标记数据和unmask数据。 转换后的数据八位字节i （transformed-octet-i）是 原始八位字节i（original-octet-i）与 标记键在 i 对 4 取模（j = i % 4）后的位序的八位字节（masking-key-octet-j）的 异或(XOR)。j = i MOD 4transformed-octet-i = original-octec-i XOR masking-key-octet-j 译者给出的Scala语言实现： def mask(key: Array[Byte],data: Array[Byte]){ for (i &lt;- 0 untildata.length) { val j = i &amp; 3 // 对4 取模 data(i) = (data(i) ^ key(j)).toByte } } 帧里的有效载荷长度指示frame-payload-length，不包括masking key的长度。它是”Payloaddata”，如，masking key的后续字节 的长度。 5.4. 分帧分帧的首要目的是允许发送开始时不知道长度的消息，不需要缓存消息。如果消息不能分帧，那么终端得缓存整个消息，以便在发送前计算长度。有了分帧，服务器或中间设施可以选择一个合理大小的缓存，当缓存满时，把帧写到网络。 分帧的第二个用例是多路复用，在不值得大消息独占逻辑输出通道的地方，多路复用需要自由地把消息划分更小的帧来更好地共享输出通道。(注意，多路技术扩展不在本文档描述。) 除非另有扩展说明，分帧没有语义上的意义。中间设施可能合并 和/或分隔帧，如果客户端和服务器没有协商扩展，或协商了扩展，但中间设施明白所有协商了的扩展，并知道如何合并 和/或拆分帧。分帧的实现在没有扩展时，发送者和接收者必须不能依赖于帧的边界。 分帧的规则：A、一个未分帧的消息包含单个帧，FIN设置为1，opcode非0。 B、一个分帧了的消息包含：开始于：单个帧，FIN设为0，opcode非0；后接 ：0个或多个帧，FIN设为0，opcode设为0；终结于：单个帧，FIN设为1，opcode设为0。一个分帧了消息在概念上等价于一个未分帧的大消息，它的有效载荷长度等于所有帧的 有效载荷长度的累加；然而，有扩展时，这可能不成立，因为扩展定义了出现的 “Extension data”的解释。例如，”Extensiondata”可能只出现在第一帧，并 用于后续的所有帧，或者”Extensiondata”出现于所有帧，且只应用于特定的那个 帧。在缺少”Extensiondata”时，下面的示例示范了分帧如何工作。 举例：如一个文本消息作为三个帧发送，第一帧的opcode是0x1，FIN是0，第二帧 的opcode是0x0，FIN是0，第三帧的opcode是0x0，FIN是1。 C、控制帧（见5.5节）可能被插入到分帧了消息中。控制帧必须不能被分帧。 D、消息的帧必须以发送者发送的顺序传递给接受者。 E、一个消息的帧必须不能交叉在其他帧的消息中，除非有扩展能够解释交叉。 F、一个终端必须能够处理消息帧中间的控制帧。 G、一个发送者可能对任意大小的非控制消息分帧。 H、客户端和服务器必须支持接收分帧和未分帧的消息。 I、由于控制帧不能分帧，中间设施必须不尝试改变控制帧。 J、中间设施必须不修改消息的帧，如果保留位的值已经被使用，且中间设施不明白这些值的含义。 在扩展已经被协商好，且中间设施不知道已协商扩展的语义的环境，中间设施必须不修改任何消息的帧。类似地，anintermediary that didn’t see theWebSocket handshake (and wasn’t notified about its content) that resulted in a WebSocketconnection MUST NOT change thefragmentation of any message of such connection. K、作为这些规则的结果，一个消息的所有帧属于同样的类型，由第一个帧的opcdoe指定。由于控制帧不能分帧，消息的所有帧的类型要么是文本、二进制数据或保留的操作码中的一个。 注意：如果控制帧不能插入，例如，ping的延迟将会很长，如果是在一个大消息后面。因此要求处理消息帧中间的控制帧。 实现注意：如果没有任何扩展，接收者不需要为了处理而缓存整个帧。例如，如果使用了流API，帧的一部分可以传递给应用程序。然而，这个假设在未来的WebSocket扩展中可能不成立。 5.5. 控制帧控制帧由操作码标识，操作码的最高位是1。当前为控制帧定义的操作码有0x8（关闭）、0x9（Ping）和0xA（Pong），操作码0xB-0xF是保留的，未定义。 控制帧用来交流WebSocket的状态，能够插入到消息的多个帧的中间。 所有的控制帧必须有一个小于等于125字节的有效载荷长度，必须不能被分帧。 5.5.1. 关闭关闭帧有个操作码0x8。 关闭帧可能包含一个主体（帧的应用数据部分）指明关闭的原因，如终端关闭，终端接收到的帧太大，或终端接收到的帧不符合终端的预期格式。如果有主体，主体的前2个字节必须是2字节的无符号整数（按网络字节序），表示以/code/（7.4节定义）的值为状态码。在2字节整数后，主体可能包含一个UTF-8编码的字符串表示原因。这些数据不一定要人类可读，但对调试友好，或给打开连接的脚本传递信息。由于不保证数据是人类可读的，客户端必须不显示给用户。 从客户端发送到服务器的关闭帧必须标记，按5.3节。 在发送关闭帧后，应用程序必须不再发送任何数据。 如果终端接收到一个关闭帧，且先前没有发送关闭帧，终端必须发送一个关闭帧作为响应。（当发送一个关闭帧作为响应时，终端典型地以接收到的状态码作为回应。）它应该尽快实施。终端可能延迟发送关闭帧，直到它的当前消息发送完成（例如，如果分帧消息的大部分已发送，终端可能在关闭帧之前发送剩余的帧）。然而，不保证已经发送了关闭帧的终端继续处理数据。 在发送和接收到关闭消息后，终端认为WebSocket连接已关闭，必须关闭底层的TCP连接。服务器必须立即关闭底层的TCP连接；客户端应该等待服务器关闭连接，但可能在发送和接收到关闭消息后关闭，例如，如果它在合理的时间间隔内没有收到TCP关闭。 如果客户端和服务器同时发送关闭消息，两端都已发送和接收到关闭消息，应该认为WebSocket连接已关闭，并关闭底层TCP连接。 5.5.2. PingPing帧包含操作码0x9。 一个Ping帧可能包含应用程序数据。 当接收到Ping帧，终端必须发送一个Pong帧响应，除非它已经接收到一个关闭帧。它应该尽快返回Pong帧作为响应。Pong帧在5.5.3节讨论。 终端可能在连接建立后、关闭前的任意时间内发送Ping帧。 注意：Ping帧可作为keepalive或作为验证远程终端是否可响应的手段。 5.5.3. PongPong帧包含操作码0xA。 5.5.2节的详细要求适用于Ping和Pong帧。 Pong 帧必须包含与被响应Ping帧的应用程序数据完全相同的数据。 如果终端接收到一个Ping 帧，且还没有对之前的Ping帧发送Pong 响应，终端可能选择发送一个Pong 帧给最近处理的Ping帧。 一个Pong 帧可能被主动发送，这作为单向心跳。对主动发送的Pong 帧的响应是不希望的。 5.6. 数据帧数据帧（如非控制帧）由操作码标识，操作码的最高位是0。当前为数据帧定义的操作码有0x1（文本），0x2（二进制）。操作码0x3-0x7 为以后的非控制帧保留，未定义。 数据帧携带 应用程序层和/或扩展层 数据。操作码决定了数据的解释：文本：有效载荷数据是UTF-8编码的文本数据。注意，特定的文本帧可能包含部分的UTF-8 序列，然而，整个消息必须包含有效的UTF-8。重新聚合后的非法的UTF-8的处理在8.1 节描述。 二进制：有效载荷数据是任意的二进制数据，它的解释由应用程序层唯一决定。 5.7. 举例单个未标记的文本消息帧：0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f(contains “Hello”) 单个标记了的文本消息帧：0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains “Hello”) 分帧了的未标记的文本消息：0x01 0x03 0x48 0x65 0x6c (contains “Hel”)0x80 0x02 0x6c 0x6f(contains “lo”) 未标记的Ping请求和标记了的Ping 响应：0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f(contains a body of “Hello”, but the contents of the body arearbitrary) 0x8a0x85 0x37 0xfa 0x21 0x3d 0x7f0x9f 0x4d 0x51 0x58 (contains abody of “Hello”, matching the body of the ping) 含有256字节二进制数据消息的单个未标记帧：0x82 0x7E 0x0100 [256 bytes of binary data] 64KB二进制数据消息在单个未标记帧：0x82 0x7F 0x0000000000010000 [65536 bytes of binary data] 5.8. 扩展协议旨在允许扩展，将给基础协议添加功能。连接的终端必须在打开握手中协商使用任意的扩展。这个规范提供了操作码0x3到0x7和0xB到0xF，帧头的“Extensiondata”域，和frame-rsv1,frame-rsv2和frame-rsv3 位供扩展使用。扩展的协商在9.1节讨论。下面是一些期望的扩展使用，这个清单既不是完整的也不是规范。A、”extensiondata” 可能在”applicationdata”之前放置。 B、保留位可能按帧的需要分配。 C、保留的操作码可以定义。 D、保留位可以分配给操作码域，如果需要更多的操作码。、 E、保留位或扩展操作码可以定义在”Payload data”外分配额外的位来定义更大的操作码或 更多的特定帧位。 发送和接收数据 发送数据为在WebSocket连接上发送一个由/data/组成的WebSocket消息，终端必须执行下面的步骤： 终端必须确保WebSocket连接处于OPEN状态。在任何时刻，如果WebSocket连接的 状态改变，终端必须终止下面的步骤。 终端必须按5.2节在WebSocket帧里封装数据。如果数据太大或者如果数据在终端准备 开始发送数据时不能完整可得，终端可能选择封装数据为一序列的帧，按5.4节。 包含数据的第一帧的操作码（frame-opcode）必须设置为恰当的值，按5.2节，因为这 决定数据将被接收者解释为文本或二进制数据。 包含数据的最后帧的FIN位（frame-fin）必须设置为1，如5.2节定义。 如果数据由客户端发送，帧必须被标记，如5.3节定义。 如果为WebSocket连接协商了扩展（第9章），额外的考虑可能按定义的扩展 应用。 已形成的帧必须在底层的网络连接上传输。 6.2. 接收数据为了接收WebSocket数据，终端监听底层的网络连接。到来的数据必须按5.2节定义的WebSocket帧解析。如果接收到控制帧，必须按5.5节的定义处理。当接收到数据帧时，终端必须知道数据的类型，通过操作码（frame-opcode）定义。帧的”Application data”是定义为消息的/data/的。如果帧包含一个未分帧的消息，就是说接收到一个包含类型和数据的WebSocket消息。如果帧是分帧了的消息的一部分，应用数据是后续帧的数据的拼接。当最后帧（有FIN位指示）接收到时，就是说WebSocket消息接收到了，数据由所有帧的应用数据拼接组成，类型由第一帧指示。后续的数据帧必须解释为属于新的WebSocket消息的。 扩展（第9章）可能改变如何读取数据的语义，具体包括什么组成消息的边界。扩展，在”Applicationdata”前添加”Extensiondata”，是计入有效载荷的，也可能修改”Application data”。 服务器必须移除从客户端接收到的数据帧的标记，如5.3节。 关闭连接 定义 1.1. 关闭WebSocket连接为关闭WebSocket连接，终端关闭底层的TCP连接。终端应该使用能够干净地关闭TCP连接和TLS会话的方法。如果可以，丢弃可能接收到的后续的任意字节。当需要时，终端可能使用任意方法关闭连接，例如受到攻击时。 在大多数情况下，应该由服务器先关闭底层的TCP连接，这样它持有TIME_WAIT状态，而不是客户端（因为这会导致它在2个最大段生命周期（2MSL）内不能重新打开，然而对服务器没有相应的影响，因为当遇到有更高序号的SYN时，TIME_WAIT连接可以立即重新打开）。在不正常的情况（例如在合适的时间内没有从服务器接收到TCP关闭）下，客户端可能开始TCP关闭。这样，当服务器得到关闭WebSocket连接指示，应该马上开始TCP关闭，当客户端得到关闭WebSocket连接的指示，它应该等待来自服务器的TCP关闭。 As an example ofhow to obtain a clean closure in C using Berkeleysockets, one wouldcall shutdown() with SHUT_WR on the socket, callrecv() untilobtaining a return value of 0 indicating that the peerhas also performedan orderly shutdown, and finally call close() onthe socket. 7.1.2. 开始WebSocket关闭握手为用状态码/code/（7.4节）和可选的关闭理由/reason/（7.1.6节）开始WebSocket关闭握手，终端必须发送一个关闭帧，如5.5.1节描述。一旦终端已经发送和接收到关闭帧，终端应该关闭WebSocket连接，如7.1.1节定义。 7.1.3. WebSocket关闭握手已开始基于正在发送或接收关闭帧，这说明WebSocket关闭握手已经开始，WebSocket连接处于CLOSING状态。 7.1.4. WebSocket连接已关闭当底层TCP连接已关闭，说明WebSocket连接已关闭，处于CLOSED状态。如果TCP连接在WebSocket关闭握手完成后关闭，就是说WebSocket连接已干净地关闭。 如果WebSocket连接没能建立，这也说WebSocket连接已关闭，但是不干净。 7.1.5. WebSocket连接关闭码如5.5.1和7.4节定义，一个关闭控制帧可能包含一个状态码指示关闭的理由。一个WebSocket连接的关闭可能由任意一方的终端发起，也可能同时。WebSocket连接的关闭码是作为状态码（7.4节）定义，包含在实现这个协议的应用程序接收到的第一个关闭控制帧。如果关闭控制帧不包含状态码，WebSocket连接的关闭码被认为是1005。如果WebSocket连接已关闭，且终端没有收到关闭控制帧（这可能出现在底层传输连接丢失的情况），WebSocket连接的关闭码被认为是1006。 注意：两个终端可能不对WebSocket连接的关闭码达成一致。例如，如果远程终端发送了一个关闭帧，但本地应用程序还没有从它自己的套接字接收缓存读取包含控制帧的数据，本地应用程序独自决定连接，并发送了一个关闭帧，两个终端都已发送和接收到一个关闭帧，不再发送更多的关闭帧。每个终端将看到另一端发送的状态码，作为WebSocket连接的关闭码。这样，在两个终端大致同时开始关闭握手的情况下，它们可能不能在WebSocket连接的关闭码上达成一致。 7.1.6. WebSocket关闭理由如5.5.1和7.4节定义，一个关闭帧可能包含状态码指示关闭的理由，后接UTF-8编码的数据，数据的解释留给终端，不在协议定义。WebSocket连接的关闭可能由两个终端的任何一方发起，也可能同时。WebSocket连接关闭理由定义为UTF-8编码的数据，跟在状态码（7.4节）后面，包含在实现本协议的应用程序接收到的一个关闭帧里。如果关闭帧里没有这样的数据，WebSocket连接关闭理由被认为是空的字符串。 注意：遵循7.1.5节提示的，两个终端可能不在WebSocket连接关闭理由上达成一致。 7.1.7. 使WebSocket连接失败特定的算法和规范要求终端使WebSocket连接失败。为此，客户端必须关闭WebSocket连接，可能通过恰当的方式把问题报告给用户（这对开发者特别有用）。类似地，服务器必须关闭WebSocket连接，并应该记录问题到日志。 如果WebSocket连接在终端要求使WebSocket连接失败之前已经建立，终端应该发生一个关闭帧，用合适的状态码，在继续关闭WebSocket连接之前。终端可能忽略发送关闭帧，如果它认为另一端不大可能接收和处理关闭帧，是因为导致WebSocket连接关闭的错误。一个终端必须不继续尝试处理来自远程终端的数据（包括响应的控制帧），在收到使WebSocket连接失败的指令后。 除了上面指示的或由应用程序层指定的，客户端不应该关闭连接。 7.2. 非正常关闭7.2.1. 客户端开始的关闭特定的算法，特别是在打开握手的时候，要求客户端使WebSocket连接失败。为此，客户端必须使WebSocket连接失败，按7.1.7节定义。 如果在底层传输层连接意外消失的任何时刻，客户端必须使WebSocket连接失败。 除了上面指示的或由应用程序层指定的，客户端不应该关闭连接。 7.2.2. 服务器端开始的关闭特殊的算法要求或建议服务器中止WebSocket连接，在打开握手的时候。为此，服务器必须简单地关闭WebSocket连接（7.1.1节）。 7.2.3. 从非正常关闭恢复非正常关闭可能由任意数量的原因导致。这样的关闭可能是由于暂时的错误，在这种情况下，重连可能导致一个好的连接，恢复到正常操作。这样的关闭也可能是因为非暂时性问题，在in whichcase if each deployed client experiences an abnormal closure and immediately andpersistently tries to reconnect, the server may experience what amounts to a denial-of-service attack by a large numberof clients trying to reconnect. The end result of such a scenario could be that the service isunable to recover in a timelymanner or recovery is made much more difficult. To prevent this,clients SHOULD use some form of backoff when tryingto reconnect afterabnormal closures as described in this section. The first reconnectattempt SHOULD be delayed by a random amount of time. The parameters by which this randomdelay is chosen are leftto the client todecide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay thoughclients MAY choose a differentinterval from which to select a delay length based on implementation experience and particularapplication. Should the firstreconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasinglylonger amounts of time, using amethod such as truncated binary exponential backoff. 7.3. 正常关闭连接服务器在需要时可能关闭WebSocket连接。客户端不应该贸然关闭WebSocket连接。在任何情况下，终端遵循开始WebSocket连接关闭握手的步骤（7.1.2节）来发起关闭。 7.4. 状态码当关闭一个已建立连接时（如，在打开握手完成后，发送一个关闭帧），终端可能指示一个关闭理由。本规范未定义终端如何解释理由和给出理由要采取的动作。本规范定义了一组预定义的状态码，指定了哪些范围可能由扩展、框架、终端应用程序使用。状态码和关联的文本消息对于关闭帧是可选的。 7.4.1. 状态码定义在发送关闭帧时，终端可能使用下面预定义的状态码。 1000：表示正常关闭，意味着连接建立的目的已完成。 1001：表示终端离开，例如服务器关闭或浏览器导航到其他页面。 1002：表示终端因为协议错误而关闭连接。 1003：表示终端因为接收到不能接受的数据而关闭（例如，只明白文本数据的终端可能发送 这个，如果它接收到二进制消息）。 1004：保留。这个特定含义可能在以后定义。 1005：保留。且终端必须不在控制帧里设置作为状态码。它是指定给应用程序而非作为状态 码 使用的，用来指示没有状态码出现。 1006：同上。保留。且终端必须不在控制帧里设置作为状态码。它是指定给应用程序而非作 为状态 码 使用的，用来指示连接非正常关闭，例如，没有发生或接收到关闭帧。 1007：表示终端因为接收到的数据没有消息类型而关闭连接。 1008：表示终端因为接收到的消息背离它的政策而关闭连接。这是一个通用的状态码，用在 没有更合适的状态码或需要隐藏具体的政策细节时。 1009：表示终端因为接收到的消息太大以至于不能处理而关闭连接。 1010：表示客户端因为想和服务器协商一个或多个扩展，而服务器不在响应消息返回它（扩 展）而关闭连接。需要的扩展列表应该出现在关闭帧的/reason/部分。注意，这个状态 码不是由服务器使用，因为它会导致WebSocket握手失败。 1011：表示服务器因为遇到非预期的情况导致它不能完成请求而关闭连接。 1015：保留，且终端必须不在控制帧里设置作为状态码。它是指定用于应用程序希望用状态 码来指示连接因为TLS握手失败而关闭。 7.4.2. 保留的状态码范围0 - 999 ：未使用。 1000 - 2999 ：此范围的保留给本协议使用的，它以后的校订和扩展将以永久的和容易获取 公开规范里指定。 3000 - 3999 ：此范围保留给类库、框架和应用程序使用。这些状态码直接在IANA注册。 本协议未定义如何解释这些状态码。 4000 - 4999 ：此范围保留给私用，且不能注册。这些值可以在预先达成一致的WebSocket 应用程序间使用。本协议未定义如何解释这些值。 错误处理 处理UTF-8编码的数据的错误当终端以UTF-8解释字节流时发现字节流不是一个合法的UTF-8流，那么终端必须使WebSocket连接失败。这个规则适用于打开握手时及后续的数据交换时。 扩展 协商扩展 已知扩展 安全考虑 10.1. 非浏览器客户端 10.2. Origin考虑 10.3. Attacks On Infrastructure 10.4. Implementation-Specific Limits 10.5. WebSocket Client Authentication 10.6. Connection Confidentiality andIntegrity 10.7. Handling of Invalid Data 10.8. Use of SHA-1 by the WebSocketHandshake IANA Considerations Using the WebSocket Protocolfrom Other Specifications","categories":[{"name":"websocket","slug":"websocket","permalink":"https://blog.clz.cloud/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://blog.clz.cloud/tags/websocket/"}]},{"title":"GO语言heap剖析","slug":"GO语言heap剖析","date":"2017-08-23T02:33:42.000Z","updated":"2019-08-10T03:21:14.313Z","comments":true,"path":"2017/08/23/GO语言heap剖析/","link":"","permalink":"https://blog.clz.cloud/2017/08/23/GO语言heap剖析/","excerpt":"","text":"heap使用在go语言的标准库container中，实现了三中数据类型：heap,list,ring，list在前面一篇文章中已经写了，现在要写的是heap（堆）的源码剖析。 首先，学会怎么使用heap，第一步当然是导入包了，代码如下： 123456package mainimport ( \"container/heap\" \"fmt\") 这个堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。源码里面只是实现了一个接口，它的定义如下： 12345type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // add x as element Len() Pop() interface&#123;&#125; // remove and return element Len() - 1.&#125; 从这个接口可以看出，其继承了sort.Interface接口，那么sort.Interface的定义是什么呢？源码如下： 123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 也就是说，我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，需要实现的方法如下： Len() int Less(i, j int) bool Swap(i, j int) Push(x interface{}) Pop() interface{} 实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。 123456789101112131415161718192021type IntHeap []int // 定义一个类型func (h IntHeap) Len() int &#123; return len(h) &#125; // 绑定len方法,返回长度func (h IntHeap) Less(i, j int) bool &#123; // 绑定less方法 return h[i] &lt; h[j] // 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆&#125;func (h IntHeap) Swap(i, j int) &#123; // 绑定swap方法，交换两个元素位置 h[i], h[j] = h[j], h[i]&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; // 绑定pop方法，从最后拿出一个元素并返回 old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; // 绑定push方法，插入新元素 *h = append(*h, x.(int))&#125; 针对IntHeap实现了这五个方法之后，我们就可以使用heap了，下面是具体使用方法： 1234567891011121314151617func main() &#123; h := &amp;IntHeap&#123;2, 1, 5, 6, 4, 3, 7, 9, 8, 0&#125; // 创建slice heap.Init(h) // 初始化heap fmt.Println(*h) fmt.Println(heap.Pop(h)) // 调用pop heap.Push(h, 6) // 调用push fmt.Println(*h) for len(*h) &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125;&#125;输出结果：[0 1 3 6 2 5 7 9 8 4]0[1 2 3 6 4 5 7 9 8 6]1 2 3 4 5 6 6 7 8 9 上面就是heap的使用了。 heap提供的方法heap提供的方法不多，具体如下： 123456h := &amp;IntHeap&#123;3, 8, 6&#125; // 创建IntHeap类型的原始数据func Init(h Interface) // 对heap进行初始化，生成小根堆（或大根堆）func Push(h Interface, x interface&#123;&#125;) // 往堆里面插入内容func Pop(h Interface) interface&#123;&#125; // 从堆顶pop出内容func Remove(h Interface, i int) interface&#123;&#125; // 从指定位置删除数据，并返回删除的数据func Fix(h Interface, i int) // 从i位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法 heap源码剖析heap的内部实现，是使用最小(最大)堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。 内部实现的down和up分别表示对堆中的某个元素向下保证最小(最大)堆和向上保证最小(最大)堆。 当往堆中插入一个元素的时候，这个元素插入到最右子树的最后一个节点中，然后调用up向上保证最小(最大)堆。 当要从堆中推出一个元素的时候，先吧这个元素和右子树最后一个节点交换，然后弹出最后一个节点，然后对root调用down，向下保证最小(最大)堆。 好了，开始分析源码： 首先，在使用堆之前，必须调用它的Init方法，初始化堆，生成小根(大根)堆。Init方法源码如下: 123456789101112// A heap must be initialized before any of the heap operations// can be used. Init is idempotent with respect to the heap invariants// and may be called whenever the heap invariants may have been invalidated.// Its complexity is O(n) where n = h.Len().//func Init(h Interface) &#123; // heapify n := h.Len() // 获取数据的长度 for i := n/2 - 1; i &gt;= 0; i-- &#123; // 从长度的一半开始，一直到第0个数据，每个位置都调用down方法，down方法实现的功能是保证从该位置往下保证形成堆 down(h, i, n) &#125;&#125; 接下来看down的源码： 12345678910111213141516171819func down(h Interface, i0, n int) bool &#123; i := i0 // 中间变量，第一次存储的是需要保证往下需要形成堆的节点位置 for &#123; // 死循环 j1 := 2*i + 1 // i节点的左子孩子 if j1 &gt;= n || j1 &lt; 0 &#123; // j1 &lt; 0 after int overflow // 保证其左子孩子没有越界 break &#125; j := j1 // left child // 中间变量j先赋值为左子孩子，之后j将被赋值为左右子孩子中最小（大）的一个孩子的位置 if j2 := j1 + 1; j2 &lt; n &amp;&amp; !h.Less(j1, j2) &#123; j = j2 // = 2*i + 2 // right child &#125; // 这之后，j被赋值为两个孩子中的最小（大）孩子的位置（最小或最大由Less中定义的决定） if !h.Less(j, i) &#123; break &#125; // 若j大于（小于）i，则终止循环 h.Swap(i, j) // 否则交换i和j位置的值 i = j // 令i=j，继续循环，保证j位置的子数是堆结构 &#125; return i &gt; i0&#125; 这是建立堆的核心代码，其实，down并不能完全保证从某个节点往下每个节点都能保持堆的特性，只能保证某个节点的值如果不满足堆的性质，则将该值与其孩子交换，直到该值放到适合的位置，保证该值及其两个子孩子满足堆的性质。 但是，如果是通过Init循环调用down将能保证初始化后所有的节点都保持堆的特性，这是因为循环开始的i := n/2 - 1的取值位置，将会取到最大的一个拥有孩子节点的节点，并且该节点最多只有两个孩子，并且其孩子节点是叶子节点，从该节点往前每个节点如果都能保证down的特性，则整个列表也就符合了堆的性质了。 同样，有down就有up，up保证的是某个节点如果向上没有保证堆的性质，则将其与父节点进行交换，直到该节点放到某个特定位置保证了堆的性质。代码如下： 12345678910func up(h Interface, j int) &#123; for &#123; // 死循环 i := (j - 1) / 2 // parent // j节点的父节点 if i == j || !h.Less(j, i) &#123; // 如果越界，或者满足堆的条件，则结束循环 break &#125; h.Swap(i, j) // 否则将该节点和父节点交换 j = i // 对父节点继续进行检查直到根节点 &#125;&#125; 以上两个方法就是最核心的方法了，所有暴露出来的方法无非就是对这两个方法进行的封装。我们来看看以下这些方法的源码： 123456789101112131415161718192021222324252627func Push(h Interface, x interface&#123;&#125;) &#123; h.Push(x) // 将新插入进来的节点放到最后 up(h, h.Len()-1) // 确保新插进来的节点网上能保证堆结构&#125;func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() - 1 // 把最后一个节点和第一个节点进行交换，之后，从根节点开始重新保证堆结构，最后把最后那个节点数据丢出并返回 h.Swap(0, n) down(h, 0, n) return h.Pop()&#125;func Remove(h Interface, i int) interface&#123;&#125; &#123; n := h.Len() - 1 pop只是remove的特殊情况，remove是把i位置的节点和最后一个节点进行交换，之后保证从i节点往下及往上都保证堆结构，最后把最后一个节点的数据丢出并返回 if n != i &#123; h.Swap(i, n) down(h, i, n) up(h, i) &#125; return h.Pop()&#125;func Fix(h Interface, i int) &#123; if !down(h, i, h.Len()) &#123; // i节点的数值发生改变后，需要保证堆的再平衡，先调用down保证该节点下面的堆结构，如果有位置交换，则需要保证该节点往上的堆结构，否则就不需要往上保证堆结构，一个小小的优化 up(h, i) &#125;&#125; 以上就是go里面的heap所有的源码了，我也就不贴出完整版源码了，以上理解全部基于个人的理解，如有不当之处，还望批评指正。 利用heap实现优先级队列既然用到了heap，那就用heap实现一个优先级队列吧，这个功能是很好的一个功能。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( \"container/heap\" \"fmt\")type Item struct &#123; value string // 优先级队列中的数据，可以是任意类型，这里使用string priority int // 优先级队列中节点的优先级 index int // index是该节点在堆中的位置&#125;// 优先级队列需要实现heap的interfacetype PriorityQueue []*Item// 绑定Len方法func (pq PriorityQueue) Len() int &#123; return len(pq)&#125;// 绑定Less方法，这里用的是小于号，生成的是小根堆func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].priority &lt; pq[j].priority&#125;// 绑定swap方法func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].index, pq[j].index = i, j&#125;// 绑定put方法，将index置为-1是为了标识该数据已经出了优先级队列了func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] *pq = old[0 : n-1] item.index = -1 return item&#125;// 绑定push方法func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item)&#125;// 更新修改了优先级和值的item在优先级队列中的位置func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123; item.value = value item.priority = priority heap.Fix(pq, item.index)&#125;func main() &#123; // 创建节点并设计他们的优先级 items := map[string]int&#123;\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9&#125; i := 0 pq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化 for k, v := range items &#123; // 将节点放到优先级队列中 pq[i] = &amp;Item&#123; value: k, priority: v, index: i&#125; i++ &#125; heap.Init(&amp;pq) // 初始化堆 item := &amp;Item&#123; // 创建一个item value: \"李四\", priority: 1, &#125; heap.Push(&amp;pq, item) // 入优先级队列 pq.update(item, item.value, 6) // 更新item的优先级 for len(pq) &gt; 0 &#123; item := heap.Pop(&amp;pq).(*Item) fmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index) &#125;&#125;输出结果：03:张三 index:-0105:二毛 index:-0106:李四 index:-0109:狗蛋 index:-01","categories":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"heap","slug":"heap","permalink":"https://blog.clz.cloud/tags/heap/"}]},{"title":"GO语言list剖析","slug":"GO语言list剖析","date":"2017-08-23T02:33:42.000Z","updated":"2019-08-10T03:21:14.317Z","comments":true,"path":"2017/08/23/GO语言list剖析/","link":"","permalink":"https://blog.clz.cloud/2017/08/23/GO语言list剖析/","excerpt":"","text":"使用方法在GO语言的标准库中，提供了一个container包，这个包中提供了三种数据类型，就是heap,list和ring，本节要讲的是list的使用以及源码剖析。要使用GO提供的list链表，则首先需要导入list包，如下所示： 1234package mainimport( \"container/list\") 导入包之后，需要了解list中定义了两种数据类型，Element和List，定义如下： 1234567891011121314151617181920// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125; Element里面定义了两个Element类型的指针next, prev以及List类型的指针list, Value用来存储值，List里面定义了一个Element作为链表的Root，len作为链表的长度。 import之后，就可以使用链表了： 12345678910func main() &#123; list_test:=list.New() // 创建list对象 list_test.PushBack(\"123\") // 往List队列尾部插入数据 list_test.PushBack(\"456\") list_test.PushBack(\"789\") fmt.Println(list_test.Len()) // 输出list长度 fmt.Println(list_test.Front()) // 输出list第一个元素 fmt.Println(list_test.Front().Next()) // 输出list第一个元素的下一个元素 fmt.Println(list_test.Front().Next().Next()) // 输出list第三个元素&#125; list提供的方法list提供的方法如下： 1234567891011121314151617181920type Element func (e *Element) Next() *Element func (e *Element) Prev() *Elementtype List func New() *List func (l *List) Back() *Element // 返回最后一个元素 func (l *List) Front() *Element // 返回第一个元素 func (l *List) Init() *List // 链表初始化 func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element // 在某个元素前插入 func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element // 在某个元素后插入 func (l *List) Len() int // 返回链表长度 func (l *List) MoveAfter(e, mark *Element) // 把e元素移动到mark之后 func (l *List) MoveBefore(e, mark *Element) // 把e元素移动到mark之前 func (l *List) MoveToBack(e *Element) // 把e元素移动到队列最后 func (l *List) MoveToFront(e *Element) // 把e元素移动到队列最头部 func (l *List) PushBack(v interface&#123;&#125;) *Element // 在队列最后插入元素 func (l *List) PushBackList(other *List) // 在队列最后插入接上新队列 func (l *List) PushFront(v interface&#123;&#125;) *Element // 在队列头部插入元素 func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列 func (l *List) Remove(e *Element) interface&#123;&#125; // 删除某个元素 源码剖析首先，使用list.New()方法，返回的是一个List对象的指针，源码New() *List &#123; return new(List).Init() &#125;```并执行了List对象的Init()方法对list进行初始化，初始化root的prev和next指针以及list的长度。1234567之后调用list_test.PushBack(&quot;123&quot;)在队列尾部插入元素123，源码如下：```gofunc (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125; 调用lazyInit(),如果链表没有初始化，则先初始化一遍，之后，调用list的insertValue方法，insertValue方法初始化节点之后，调用insert方法进行插入链表。 123func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125; 整篇文章最精髓的地方就在insert方法中了，源码如下： 12345678910func (l *List) insert(e, at *Element) *Element &#123; n := at.next // 用中间变量n保存at节点的next指针 at.next = e // at节点的next指向要插入的节点 e.prev = at // 要插入的节点e的prev指向at节点 e.next = n // e的next节点指向中间变量n保存的指针 n.prev = e // at节点的下一个节点的prev指向e节点 e.list = l // e节点的list指向链表的root节点 l.len++ // 链表的长度加一 return e // 返回刚插入节点的指针&#125; 这里的链表结构是双向链表，并且在root节点的prev指针指向了链表的结尾，链表结尾的next指针也指向了root节点，这样，其实形成了一个环形结构，如果是向链表的尾部插入新数据，则将root.prev传递给insert方法的at参数，如果是向头部插入，则将root传递给insert方法的at参数。 这样做的好处是显而易见的，那就是从链表的尾部插入数据，将不需要遍历一遍链表，而只需要将root节点的prev传递给insert方法中就可以了，大大节省了从尾部插入节点的时间。这段代码我看了很久，觉得这个包中最精髓的地方也就在这了，这也是这篇文章诞生的原因。 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package list implements a doubly linked list.//// To iterate over a list (where l is a *List):// for e := l.Front(); e != nil; e = e.Next() &#123;// // do something with e.Value// &#125;//package list// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// Next returns the next list element or nil.func (e *Element) Next() *Element &#123; if p := e.next; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// Prev returns the previous list element or nil.func (e *Element) Prev() *Element &#123; if p := e.prev; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125;// Len returns the number of elements of list l.// The complexity is O(1).func (l *List) Len() int &#123; return l.len &#125;// Front returns the first element of list l or nil.func (l *List) Front() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.next&#125;// Back returns the last element of list l or nil.func (l *List) Back() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.prev&#125;// lazyInit lazily initializes a zero List value.func (l *List) lazyInit() &#123; if l.root.next == nil &#123; l.Init() &#125;&#125;// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// remove removes e from its list, decrements l.len, and returns e.func (l *List) remove(e *Element) *Element &#123; e.prev.next = e.next e.next.prev = e.prev e.next = nil // avoid memory leaks e.prev = nil // avoid memory leaks e.list = nil l.len-- return e&#125;// Remove removes e from l if e is an element of list l.// It returns the element value e.Value.func (l *List) Remove(e *Element) interface&#123;&#125; &#123; if e.list == l &#123; // if e.list == l, l must have been initialized when e was inserted // in l or l == nil (e is a zero Element) and l.remove will crash l.remove(e) &#125; return e.Value&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125;// MoveToFront moves element e to the front of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToFront(e *Element) &#123; if e.list != l || l.root.next == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), &amp;l.root)&#125;// MoveToBack moves element e to the back of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToBack(e *Element) &#123; if e.list != l || l.root.prev == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), l.root.prev)&#125;// MoveBefore moves element e to its new position before mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveBefore(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark.prev)&#125;// MoveAfter moves element e to its new position after mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveAfter(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark)&#125;// PushBackList inserts a copy of an other list at the back of list l.// The lists l and other may be the same.func (l *List) PushBackList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() &#123; l.insertValue(e.Value, l.root.prev) &#125;&#125;// PushFrontList inserts a copy of an other list at the front of list l.// The lists l and other may be the same.func (l *List) PushFrontList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() &#123; l.insertValue(e.Value, &amp;l.root) &#125;&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"list","slug":"list","permalink":"https://blog.clz.cloud/tags/list/"}]},{"title":"centos 7 安装mariadb","slug":"centos 7 安装mariadb","date":"2017-08-23T02:33:42.000Z","updated":"2019-08-12T12:58:55.066Z","comments":true,"path":"2017/08/23/centos 7 安装mariadb/","link":"","permalink":"https://blog.clz.cloud/2017/08/23/centos 7 安装mariadb/","excerpt":"","text":"@TOC 序言听说Oracle 公司要对mysql 进行推出收费版本了,一般收费版本肯定要比免费使用的版本功能更强大些,所以我感觉说不定要对免费版本限制功能了,那这样的话,还不如开始使用MySQL原作者推出的免费版–mariadb其实就一点,跟centos一个样 免费跟收费的区别,所以一般公司用的还大多是centos ,为啥 不收费呀! ,而且centos就是rhel是一模一样的,唯一的差别改了一个图标而已,t同理,mysql跟mariadb底层是通用的,mariadb兼容MySQL,而且在MySQL的基础上增加了很多功能,更为强大好用 &nbsp; 由于官网的MariaDB版本要比阿里云的版本要高，所以我们应该优先使用官方的版本 注意: 在centos7 中默认使用的数据库已经切换成了mariadb,所以我们通过yum安装的时候,直接安装MySQL就行 首先 添加MariaDB yum仓库 1、首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB.repo 文件。12# 编辑创建mariadb.repo仓库文件vi /etc/yum.repos.d/MariaDB.repo 2、添加repo仓库配置12345[mariadb]name=MariaDBbaseurl=http://yum.mariadb.org/10.1/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1 3、当 MariaDB 仓库地址添加好后，你可以通过下面的一行命令轻松安装 MariaDB。1yum install MariaDB-server MariaDB-client -y 4、如果官方的版本下载太慢，我们就直接使用阿里云的比较低的版本也可以(1) 删除或者重命名刚才创建的Mariadb.repo文件 12cd /etc/yum.repos.dmv Mariadb.repo Mariadb.repo.bak (2) 然后一条命令安装Mariadb 1yum install mariadb-server mariadb -y 5 启动mariadb命令mariadb数据库的相关命令是： 1234systemctl start mariadb # 启动MariaDBsystemctl stop mariadb # 停止MariaDBsystemctl restart mariadb # 重启MariaDBsystemctl enable mariadb # 设置开机启动 6 初始化mysql1mysql_secure_installation 7 使用mysql命令进入数据库1mysql -u root -p 8 mysql基本操作12345671 创建数据库2 创建表create table qishitb (id int, name char(11));3 插入数据insert into qishitb values(1, \"陈鹏\");4 查看数据select * from qishitb; 12345查看数据库的信息\\s查看表的编码信息show create table qishitb 9 解决中文乱码问题(1) 修改配置文件 1vim /etc/my.cnf (2) 添加以下配置文件(如图) 12345678[mysqld]character-set-server=utf8collation-server=utf8_general_cilog-error=/var/log/mysqld.log[client]default-character-set=utf8[mysql]default-character-set=utf8 (3) 重启数据库 1systemctl restart mariadb","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.clz.cloud/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"}]}]}